module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *\r\n */\r\nfunction makeEmptyFunction(arg) {\r\n    return function () {\r\n        return arg;\r\n    };\r\n}\r\n/**\r\n * This function accepts and discards inputs; it has no side effects. This is\r\n * primarily useful idiomatically for overridable function endpoints which\r\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\r\n */\r\nvar emptyFunction = function emptyFunction() { };\r\nemptyFunction.thatReturns = makeEmptyFunction;\r\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\r\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\r\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\r\nemptyFunction.thatReturnsThis = function () {\r\n    return this;\r\n};\r\nemptyFunction.thatReturnsArgument = function (arg) {\r\n    return arg;\r\n};\r\nmodule.exports = emptyFunction;\r\n\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/emptyFunction.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nvar emptyObject = {};\r\nif (true) {\r\n    Object.freeze(emptyObject);\r\n}\r\nmodule.exports = emptyObject;\r\n\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/emptyObject.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\n/**\r\n * Use invariant() to assert state which your program assumes to be true.\r\n *\r\n * Provide sprintf-style format (only %s is supported) and arguments\r\n * to provide information about what broke and what you were\r\n * expecting.\r\n *\r\n * The invariant message will be stripped in production, but the invariant\r\n * will remain to ensure logic does not differ in production.\r\n */\r\nvar validateFormat = function validateFormat(format) { };\r\nif (true) {\r\n    validateFormat = function validateFormat(format) {\r\n        if (format === undefined) {\r\n            throw new Error('invariant requires an error message argument');\r\n        }\r\n    };\r\n}\r\nfunction invariant(condition, format, a, b, c, d, e, f) {\r\n    validateFormat(format);\r\n    if (!condition) {\r\n        var error;\r\n        if (format === undefined) {\r\n            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\r\n        }\r\n        else {\r\n            var args = [a, b, c, d, e, f];\r\n            var argIndex = 0;\r\n            error = new Error(format.replace(/%s/g, function () {\r\n                return args[argIndex++];\r\n            }));\r\n            error.name = 'Invariant Violation';\r\n        }\r\n        error.framesToPop = 1; // we don't care about invariant's own frame\r\n        throw error;\r\n    }\r\n}\r\nmodule.exports = invariant;\r\n\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/invariant.js?");

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\r\n/**\r\n * Similar to invariant but only logs a warning if the condition is not met.\r\n * This can be used to log issues in development environments in critical\r\n * paths. Removing the logging code for production environments will keep the\r\n * same logic and follow the same code paths.\r\n */\r\nvar warning = emptyFunction;\r\nif (true) {\r\n    var printWarning = function printWarning(format) {\r\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n            args[_key - 1] = arguments[_key];\r\n        }\r\n        var argIndex = 0;\r\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\r\n            return args[argIndex++];\r\n        });\r\n        if (typeof console !== 'undefined') {\r\n            console.error(message);\r\n        }\r\n        try {\r\n            // --- Welcome to debugging React ---\r\n            // This error was thrown as a convenience so that you can use this stack\r\n            // to find the callsite that caused this warning to fire.\r\n            throw new Error(message);\r\n        }\r\n        catch (x) { }\r\n    };\r\n    warning = function warning(condition, format) {\r\n        if (format === undefined) {\r\n            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\r\n        }\r\n        if (format.indexOf('Failed Composite propType: ') === 0) {\r\n            return; // Ignore CompositeComponent proptype check.\r\n        }\r\n        if (!condition) {\r\n            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\r\n                args[_key2 - 2] = arguments[_key2];\r\n            }\r\n            printWarning.apply(undefined, [format].concat(args));\r\n        }\r\n    };\r\n}\r\nmodule.exports = warning;\r\n\n\n//# sourceURL=webpack:///./node_modules/fbjs/lib/warning.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\nobject-assign\r\n(c) Sindre Sorhus\r\n@license MIT\r\n*/\r\n\r\n/* eslint-disable no-unused-vars */\r\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\r\nfunction toObject(val) {\r\n    if (val === null || val === undefined) {\r\n        throw new TypeError('Object.assign cannot be called with null or undefined');\r\n    }\r\n    return Object(val);\r\n}\r\nfunction shouldUseNative() {\r\n    try {\r\n        if (!Object.assign) {\r\n            return false;\r\n        }\r\n        // Detect buggy property enumeration order in older V8 versions.\r\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\r\n        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\r\n        test1[5] = 'de';\r\n        if (Object.getOwnPropertyNames(test1)[0] === '5') {\r\n            return false;\r\n        }\r\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\r\n        var test2 = {};\r\n        for (var i = 0; i < 10; i++) {\r\n            test2['_' + String.fromCharCode(i)] = i;\r\n        }\r\n        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\r\n            return test2[n];\r\n        });\r\n        if (order2.join('') !== '0123456789') {\r\n            return false;\r\n        }\r\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\r\n        var test3 = {};\r\n        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\r\n            test3[letter] = letter;\r\n        });\r\n        if (Object.keys(Object.assign({}, test3)).join('') !==\r\n            'abcdefghijklmnopqrst') {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        // We don't expect any of the above to throw, but better to be safe.\r\n        return false;\r\n    }\r\n}\r\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\r\n    var from;\r\n    var to = toObject(target);\r\n    var symbols;\r\n    for (var s = 1; s < arguments.length; s++) {\r\n        from = Object(arguments[s]);\r\n        for (var key in from) {\r\n            if (hasOwnProperty.call(from, key)) {\r\n                to[key] = from[key];\r\n            }\r\n        }\r\n        if (getOwnPropertySymbols) {\r\n            symbols = getOwnPropertySymbols(from);\r\n            for (var i = 0; i < symbols.length; i++) {\r\n                if (propIsEnumerable.call(from, symbols[i])) {\r\n                    to[symbols[i]] = from[symbols[i]];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return to;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nvar printWarning = function () { };\r\nif (true) {\r\n    var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\r\n    var loggedTypeFailures = {};\r\n    printWarning = function (text) {\r\n        var message = 'Warning: ' + text;\r\n        if (typeof console !== 'undefined') {\r\n            console.error(message);\r\n        }\r\n        try {\r\n            // --- Welcome to debugging React ---\r\n            // This error was thrown as a convenience so that you can use this stack\r\n            // to find the callsite that caused this warning to fire.\r\n            throw new Error(message);\r\n        }\r\n        catch (x) { }\r\n    };\r\n}\r\n/**\r\n * Assert that the values match with the type specs.\r\n * Error messages are memorized and will only be shown once.\r\n *\r\n * @param {object} typeSpecs Map of name to a ReactPropType\r\n * @param {object} values Runtime values that need to be type-checked\r\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\r\n * @param {string} componentName Name of the component for error messages.\r\n * @param {?Function} getStack Returns the component stack.\r\n * @private\r\n */\r\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\r\n    if (true) {\r\n        for (var typeSpecName in typeSpecs) {\r\n            if (typeSpecs.hasOwnProperty(typeSpecName)) {\r\n                var error;\r\n                // Prop type validation may throw. In case they do, we don't want to\r\n                // fail the render phase where it didn't fail before. So we log it.\r\n                // After these have been cleaned up, we'll let them throw.\r\n                try {\r\n                    // This is intentionally an invariant that gets caught. It's the same\r\n                    // behavior as without this statement except with a better message.\r\n                    if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n                        var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\r\n                            'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');\r\n                        err.name = 'Invariant Violation';\r\n                        throw err;\r\n                    }\r\n                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\r\n                }\r\n                catch (ex) {\r\n                    error = ex;\r\n                }\r\n                if (error && !(error instanceof Error)) {\r\n                    printWarning((componentName || 'React class') + ': type specification of ' +\r\n                        location + ' `' + typeSpecName + '` is invalid; the type checker ' +\r\n                        'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\r\n                        'You may have forgotten to pass an argument to the type checker ' +\r\n                        'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\r\n                        'shape all require an argument).');\r\n                }\r\n                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\r\n                    // Only monitor this failure once because there tends to be a lot of the\r\n                    // same error.\r\n                    loggedTypeFailures[error.message] = true;\r\n                    var stack = getStack ? getStack() : '';\r\n                    printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nmodule.exports = checkPropTypes;\r\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/checkPropTypes.js?");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\r\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\r\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\r\nvar printWarning = function () { };\r\nif (true) {\r\n    printWarning = function (text) {\r\n        var message = 'Warning: ' + text;\r\n        if (typeof console !== 'undefined') {\r\n            console.error(message);\r\n        }\r\n        try {\r\n            // --- Welcome to debugging React ---\r\n            // This error was thrown as a convenience so that you can use this stack\r\n            // to find the callsite that caused this warning to fire.\r\n            throw new Error(message);\r\n        }\r\n        catch (x) { }\r\n    };\r\n}\r\nfunction emptyFunctionThatReturnsNull() {\r\n    return null;\r\n}\r\nmodule.exports = function (isValidElement, throwOnDirectAccess) {\r\n    /* global Symbol */\r\n    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\r\n    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\r\n    /**\r\n     * Returns the iterator method function contained on the iterable object.\r\n     *\r\n     * Be sure to invoke the function with the iterable as context:\r\n     *\r\n     *     var iteratorFn = getIteratorFn(myIterable);\r\n     *     if (iteratorFn) {\r\n     *       var iterator = iteratorFn.call(myIterable);\r\n     *       ...\r\n     *     }\r\n     *\r\n     * @param {?object} maybeIterable\r\n     * @return {?function}\r\n     */\r\n    function getIteratorFn(maybeIterable) {\r\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\r\n        if (typeof iteratorFn === 'function') {\r\n            return iteratorFn;\r\n        }\r\n    }\r\n    /**\r\n     * Collection of methods that allow declaration and validation of props that are\r\n     * supplied to React components. Example usage:\r\n     *\r\n     *   var Props = require('ReactPropTypes');\r\n     *   var MyArticle = React.createClass({\r\n     *     propTypes: {\r\n     *       // An optional string prop named \"description\".\r\n     *       description: Props.string,\r\n     *\r\n     *       // A required enum prop named \"category\".\r\n     *       category: Props.oneOf(['News','Photos']).isRequired,\r\n     *\r\n     *       // A prop named \"dialog\" that requires an instance of Dialog.\r\n     *       dialog: Props.instanceOf(Dialog).isRequired\r\n     *     },\r\n     *     render: function() { ... }\r\n     *   });\r\n     *\r\n     * A more formal specification of how these methods are used:\r\n     *\r\n     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\r\n     *   decl := ReactPropTypes.{type}(.isRequired)?\r\n     *\r\n     * Each and every declaration produces a function with the same signature. This\r\n     * allows the creation of custom validation functions. For example:\r\n     *\r\n     *  var MyLink = React.createClass({\r\n     *    propTypes: {\r\n     *      // An optional string or URI prop named \"href\".\r\n     *      href: function(props, propName, componentName) {\r\n     *        var propValue = props[propName];\r\n     *        if (propValue != null && typeof propValue !== 'string' &&\r\n     *            !(propValue instanceof URI)) {\r\n     *          return new Error(\r\n     *            'Expected a string or an URI for ' + propName + ' in ' +\r\n     *            componentName\r\n     *          );\r\n     *        }\r\n     *      }\r\n     *    },\r\n     *    render: function() {...}\r\n     *  });\r\n     *\r\n     * @internal\r\n     */\r\n    var ANONYMOUS = '<<anonymous>>';\r\n    // Important!\r\n    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\r\n    var ReactPropTypes = {\r\n        array: createPrimitiveTypeChecker('array'),\r\n        bool: createPrimitiveTypeChecker('boolean'),\r\n        func: createPrimitiveTypeChecker('function'),\r\n        number: createPrimitiveTypeChecker('number'),\r\n        object: createPrimitiveTypeChecker('object'),\r\n        string: createPrimitiveTypeChecker('string'),\r\n        symbol: createPrimitiveTypeChecker('symbol'),\r\n        any: createAnyTypeChecker(),\r\n        arrayOf: createArrayOfTypeChecker,\r\n        element: createElementTypeChecker(),\r\n        instanceOf: createInstanceTypeChecker,\r\n        node: createNodeChecker(),\r\n        objectOf: createObjectOfTypeChecker,\r\n        oneOf: createEnumTypeChecker,\r\n        oneOfType: createUnionTypeChecker,\r\n        shape: createShapeTypeChecker,\r\n        exact: createStrictShapeTypeChecker,\r\n    };\r\n    /**\r\n     * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n     */\r\n    /*eslint-disable no-self-compare*/\r\n    function is(x, y) {\r\n        // SameValue algorithm\r\n        if (x === y) {\r\n            // Steps 1-5, 7-10\r\n            // Steps 6.b-6.e: +0 != -0\r\n            return x !== 0 || 1 / x === 1 / y;\r\n        }\r\n        else {\r\n            // Step 6.a: NaN == NaN\r\n            return x !== x && y !== y;\r\n        }\r\n    }\r\n    /*eslint-enable no-self-compare*/\r\n    /**\r\n     * We use an Error-like object for backward compatibility as people may call\r\n     * PropTypes directly and inspect their output. However, we don't use real\r\n     * Errors anymore. We don't inspect their stack anyway, and creating them\r\n     * is prohibitively expensive if they are created too often, such as what\r\n     * happens in oneOfType() for any type before the one that matched.\r\n     */\r\n    function PropTypeError(message) {\r\n        this.message = message;\r\n        this.stack = '';\r\n    }\r\n    // Make `instanceof Error` still work for returned errors.\r\n    PropTypeError.prototype = Error.prototype;\r\n    function createChainableTypeChecker(validate) {\r\n        if (true) {\r\n            var manualPropTypeCallCache = {};\r\n            var manualPropTypeWarningCount = 0;\r\n        }\r\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\r\n            componentName = componentName || ANONYMOUS;\r\n            propFullName = propFullName || propName;\r\n            if (secret !== ReactPropTypesSecret) {\r\n                if (throwOnDirectAccess) {\r\n                    // New behavior only for users of `prop-types` package\r\n                    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\r\n                        'Use `PropTypes.checkPropTypes()` to call them. ' +\r\n                        'Read more at http://fb.me/use-check-prop-types');\r\n                    err.name = 'Invariant Violation';\r\n                    throw err;\r\n                }\r\n                else if (\"development\" !== 'production' && typeof console !== 'undefined') {\r\n                    // Old behavior for people using React.PropTypes\r\n                    var cacheKey = componentName + ':' + propName;\r\n                    if (!manualPropTypeCallCache[cacheKey] &&\r\n                        // Avoid spamming the console because they are often not actionable except for lib authors\r\n                        manualPropTypeWarningCount < 3) {\r\n                        printWarning('You are manually calling a React.PropTypes validation ' +\r\n                            'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\r\n                            'and will throw in the standalone `prop-types` package. ' +\r\n                            'You may be seeing this warning due to a third-party PropTypes ' +\r\n                            'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');\r\n                        manualPropTypeCallCache[cacheKey] = true;\r\n                        manualPropTypeWarningCount++;\r\n                    }\r\n                }\r\n            }\r\n            if (props[propName] == null) {\r\n                if (isRequired) {\r\n                    if (props[propName] === null) {\r\n                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\r\n                    }\r\n                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\r\n                }\r\n                return null;\r\n            }\r\n            else {\r\n                return validate(props, propName, componentName, location, propFullName);\r\n            }\r\n        }\r\n        var chainedCheckType = checkType.bind(null, false);\r\n        chainedCheckType.isRequired = checkType.bind(null, true);\r\n        return chainedCheckType;\r\n    }\r\n    function createPrimitiveTypeChecker(expectedType) {\r\n        function validate(props, propName, componentName, location, propFullName, secret) {\r\n            var propValue = props[propName];\r\n            var propType = getPropType(propValue);\r\n            if (propType !== expectedType) {\r\n                // `propValue` being instance of, say, date/regexp, pass the 'object'\r\n                // check, but we can offer a more precise error message here rather than\r\n                // 'of type `object`'.\r\n                var preciseType = getPreciseType(propValue);\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createAnyTypeChecker() {\r\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\r\n    }\r\n    function createArrayOfTypeChecker(typeChecker) {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            if (typeof typeChecker !== 'function') {\r\n                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\r\n            }\r\n            var propValue = props[propName];\r\n            if (!Array.isArray(propValue)) {\r\n                var propType = getPropType(propValue);\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\r\n            }\r\n            for (var i = 0; i < propValue.length; i++) {\r\n                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\r\n                if (error instanceof Error) {\r\n                    return error;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createElementTypeChecker() {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            var propValue = props[propName];\r\n            if (!isValidElement(propValue)) {\r\n                var propType = getPropType(propValue);\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createInstanceTypeChecker(expectedClass) {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            if (!(props[propName] instanceof expectedClass)) {\r\n                var expectedClassName = expectedClass.name || ANONYMOUS;\r\n                var actualClassName = getClassName(props[propName]);\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createEnumTypeChecker(expectedValues) {\r\n        if (!Array.isArray(expectedValues)) {\r\n             true ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : undefined;\r\n            return emptyFunctionThatReturnsNull;\r\n        }\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            var propValue = props[propName];\r\n            for (var i = 0; i < expectedValues.length; i++) {\r\n                if (is(propValue, expectedValues[i])) {\r\n                    return null;\r\n                }\r\n            }\r\n            var valuesString = JSON.stringify(expectedValues);\r\n            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createObjectOfTypeChecker(typeChecker) {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            if (typeof typeChecker !== 'function') {\r\n                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\r\n            }\r\n            var propValue = props[propName];\r\n            var propType = getPropType(propValue);\r\n            if (propType !== 'object') {\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\r\n            }\r\n            for (var key in propValue) {\r\n                if (propValue.hasOwnProperty(key)) {\r\n                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\r\n                    if (error instanceof Error) {\r\n                        return error;\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createUnionTypeChecker(arrayOfTypeCheckers) {\r\n        if (!Array.isArray(arrayOfTypeCheckers)) {\r\n             true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\r\n            return emptyFunctionThatReturnsNull;\r\n        }\r\n        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\r\n            var checker = arrayOfTypeCheckers[i];\r\n            if (typeof checker !== 'function') {\r\n                printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\r\n                    'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');\r\n                return emptyFunctionThatReturnsNull;\r\n            }\r\n        }\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\r\n                var checker = arrayOfTypeCheckers[i];\r\n                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\r\n                    return null;\r\n                }\r\n            }\r\n            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createNodeChecker() {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            if (!isNode(props[propName])) {\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createShapeTypeChecker(shapeTypes) {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            var propValue = props[propName];\r\n            var propType = getPropType(propValue);\r\n            if (propType !== 'object') {\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\r\n            }\r\n            for (var key in shapeTypes) {\r\n                var checker = shapeTypes[key];\r\n                if (!checker) {\r\n                    continue;\r\n                }\r\n                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\r\n                if (error) {\r\n                    return error;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function createStrictShapeTypeChecker(shapeTypes) {\r\n        function validate(props, propName, componentName, location, propFullName) {\r\n            var propValue = props[propName];\r\n            var propType = getPropType(propValue);\r\n            if (propType !== 'object') {\r\n                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\r\n            }\r\n            // We need to check all keys in case some are required but missing from\r\n            // props.\r\n            var allKeys = assign({}, props[propName], shapeTypes);\r\n            for (var key in allKeys) {\r\n                var checker = shapeTypes[key];\r\n                if (!checker) {\r\n                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\r\n                        '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\r\n                        '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));\r\n                }\r\n                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\r\n                if (error) {\r\n                    return error;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        return createChainableTypeChecker(validate);\r\n    }\r\n    function isNode(propValue) {\r\n        switch (typeof propValue) {\r\n            case 'number':\r\n            case 'string':\r\n            case 'undefined':\r\n                return true;\r\n            case 'boolean':\r\n                return !propValue;\r\n            case 'object':\r\n                if (Array.isArray(propValue)) {\r\n                    return propValue.every(isNode);\r\n                }\r\n                if (propValue === null || isValidElement(propValue)) {\r\n                    return true;\r\n                }\r\n                var iteratorFn = getIteratorFn(propValue);\r\n                if (iteratorFn) {\r\n                    var iterator = iteratorFn.call(propValue);\r\n                    var step;\r\n                    if (iteratorFn !== propValue.entries) {\r\n                        while (!(step = iterator.next()).done) {\r\n                            if (!isNode(step.value)) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Iterator will provide entry [k,v] tuples rather than values.\r\n                        while (!(step = iterator.next()).done) {\r\n                            var entry = step.value;\r\n                            if (entry) {\r\n                                if (!isNode(entry[1])) {\r\n                                    return false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    function isSymbol(propType, propValue) {\r\n        // Native Symbol.\r\n        if (propType === 'symbol') {\r\n            return true;\r\n        }\r\n        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\r\n        if (propValue['@@toStringTag'] === 'Symbol') {\r\n            return true;\r\n        }\r\n        // Fallback for non-spec compliant Symbols which are polyfilled.\r\n        if (typeof Symbol === 'function' && propValue instanceof Symbol) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // Equivalent of `typeof` but with special handling for array and regexp.\r\n    function getPropType(propValue) {\r\n        var propType = typeof propValue;\r\n        if (Array.isArray(propValue)) {\r\n            return 'array';\r\n        }\r\n        if (propValue instanceof RegExp) {\r\n            // Old webkits (at least until Android 4.0) return 'function' rather than\r\n            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\r\n            // passes PropTypes.object.\r\n            return 'object';\r\n        }\r\n        if (isSymbol(propType, propValue)) {\r\n            return 'symbol';\r\n        }\r\n        return propType;\r\n    }\r\n    // This handles more types than `getPropType`. Only used for error messages.\r\n    // See `createPrimitiveTypeChecker`.\r\n    function getPreciseType(propValue) {\r\n        if (typeof propValue === 'undefined' || propValue === null) {\r\n            return '' + propValue;\r\n        }\r\n        var propType = getPropType(propValue);\r\n        if (propType === 'object') {\r\n            if (propValue instanceof Date) {\r\n                return 'date';\r\n            }\r\n            else if (propValue instanceof RegExp) {\r\n                return 'regexp';\r\n            }\r\n        }\r\n        return propType;\r\n    }\r\n    // Returns a string that is postfixed to a warning about an invalid type.\r\n    // For example, \"undefined\" or \"of type array\"\r\n    function getPostfixForTypeWarning(value) {\r\n        var type = getPreciseType(value);\r\n        switch (type) {\r\n            case 'array':\r\n            case 'object':\r\n                return 'an ' + type;\r\n            case 'boolean':\r\n            case 'date':\r\n            case 'regexp':\r\n                return 'a ' + type;\r\n            default:\r\n                return type;\r\n        }\r\n    }\r\n    // Returns class name of the object, if any.\r\n    function getClassName(propValue) {\r\n        if (!propValue.constructor || !propValue.constructor.name) {\r\n            return ANONYMOUS;\r\n        }\r\n        return propValue.constructor.name;\r\n    }\r\n    ReactPropTypes.checkPropTypes = checkPropTypes;\r\n    ReactPropTypes.PropTypes = ReactPropTypes;\r\n    return ReactPropTypes;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/factoryWithTypeCheckers.js?");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\nif (true) {\r\n    var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\r\n        Symbol.for &&\r\n        Symbol.for('react.element')) ||\r\n        0xeac7;\r\n    var isValidElement = function (object) {\r\n        return typeof object === 'object' &&\r\n            object !== null &&\r\n            object.$$typeof === REACT_ELEMENT_TYPE;\r\n    };\r\n    // By explicitly using `prop-types` you are opting into new development behavior.\r\n    // http://fb.me/prop-types-in-prod\r\n    var throwOnDirectAccess = true;\r\n    module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(isValidElement, throwOnDirectAccess);\r\n}\r\nelse {}\r\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/index.js?");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\r\nmodule.exports = ReactPropTypesSecret;\r\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.4.0\r\n * react.development.js\r\n *\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nif (true) {\r\n    (function () {\r\n        'use strict';\r\n        var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\r\n        var invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\r\n        var emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\r\n        var warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\r\n        var emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\r\n        var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\r\n        // TODO: this is special because it gets imported during build.\r\n        var ReactVersion = '16.4.0';\r\n        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\r\n        // nor polyfill, then a plain number is used for performance.\r\n        var hasSymbol = typeof Symbol === 'function' && Symbol.for;\r\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\r\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\r\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\r\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\r\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\r\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\r\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\r\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\r\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\r\n        var REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1;\r\n        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\r\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\r\n        function getIteratorFn(maybeIterable) {\r\n            if (maybeIterable === null || typeof maybeIterable === 'undefined') {\r\n                return null;\r\n            }\r\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n            if (typeof maybeIterator === 'function') {\r\n                return maybeIterator;\r\n            }\r\n            return null;\r\n        }\r\n        // Relying on the `invariant()` implementation lets us\r\n        // have preserve the format and params in the www builds.\r\n        // Exports ReactDOM.createRoot\r\n        // Experimental error-boundary API that can recover from errors within a single\r\n        // render phase\r\n        // Suspense\r\n        var enableSuspense = false;\r\n        // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\r\n        // In some cases, StrictMode should also double-render lifecycles.\r\n        // This can be confusing for tests though,\r\n        // And it can be bad for performance in production.\r\n        // This feature flag can be used to control the behavior:\r\n        // To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\r\n        // replay the begin phase of a failed component inside invokeGuardedCallback.\r\n        // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\r\n        // Warn about legacy context API\r\n        // Gather advanced timing metrics for Profiler subtrees.\r\n        // Fires getDerivedStateFromProps for state *or* props changes\r\n        // Only used in www builds.\r\n        /**\r\n         * Forked from fbjs/warning:\r\n         * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\r\n         *\r\n         * Only change is we use console.warn instead of console.error,\r\n         * and do nothing when 'console' is not supported.\r\n         * This really simplifies the code.\r\n         * ---\r\n         * Similar to invariant but only logs a warning if the condition is not met.\r\n         * This can be used to log issues in development environments in critical\r\n         * paths. Removing the logging code for production environments will keep the\r\n         * same logic and follow the same code paths.\r\n         */\r\n        var lowPriorityWarning = function () { };\r\n        {\r\n            var printWarning = function (format) {\r\n                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n                    args[_key - 1] = arguments[_key];\r\n                }\r\n                var argIndex = 0;\r\n                var message = 'Warning: ' + format.replace(/%s/g, function () {\r\n                    return args[argIndex++];\r\n                });\r\n                if (typeof console !== 'undefined') {\r\n                    console.warn(message);\r\n                }\r\n                try {\r\n                    // --- Welcome to debugging React ---\r\n                    // This error was thrown as a convenience so that you can use this stack\r\n                    // to find the callsite that caused this warning to fire.\r\n                    throw new Error(message);\r\n                }\r\n                catch (x) { }\r\n            };\r\n            lowPriorityWarning = function (condition, format) {\r\n                if (format === undefined) {\r\n                    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\r\n                }\r\n                if (!condition) {\r\n                    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\r\n                        args[_key2 - 2] = arguments[_key2];\r\n                    }\r\n                    printWarning.apply(undefined, [format].concat(args));\r\n                }\r\n            };\r\n        }\r\n        var lowPriorityWarning$1 = lowPriorityWarning;\r\n        var didWarnStateUpdateForUnmountedComponent = {};\r\n        function warnNoop(publicInstance, callerName) {\r\n            {\r\n                var _constructor = publicInstance.constructor;\r\n                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\r\n                var warningKey = componentName + '.' + callerName;\r\n                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\r\n                    return;\r\n                }\r\n                warning(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\r\n                didWarnStateUpdateForUnmountedComponent[warningKey] = true;\r\n            }\r\n        }\r\n        /**\r\n         * This is the abstract API for an update queue.\r\n         */\r\n        var ReactNoopUpdateQueue = {\r\n            /**\r\n             * Checks whether or not this composite component is mounted.\r\n             * @param {ReactClass} publicInstance The instance we want to test.\r\n             * @return {boolean} True if mounted, false otherwise.\r\n             * @protected\r\n             * @final\r\n             */\r\n            isMounted: function (publicInstance) {\r\n                return false;\r\n            },\r\n            /**\r\n             * Forces an update. This should only be invoked when it is known with\r\n             * certainty that we are **not** in a DOM transaction.\r\n             *\r\n             * You may want to call this when you know that some deeper aspect of the\r\n             * component's state has changed but `setState` was not called.\r\n             *\r\n             * This will not invoke `shouldComponentUpdate`, but it will invoke\r\n             * `componentWillUpdate` and `componentDidUpdate`.\r\n             *\r\n             * @param {ReactClass} publicInstance The instance that should rerender.\r\n             * @param {?function} callback Called after component is updated.\r\n             * @param {?string} callerName name of the calling function in the public API.\r\n             * @internal\r\n             */\r\n            enqueueForceUpdate: function (publicInstance, callback, callerName) {\r\n                warnNoop(publicInstance, 'forceUpdate');\r\n            },\r\n            /**\r\n             * Replaces all of the state. Always use this or `setState` to mutate state.\r\n             * You should treat `this.state` as immutable.\r\n             *\r\n             * There is no guarantee that `this.state` will be immediately updated, so\r\n             * accessing `this.state` after calling this method may return the old value.\r\n             *\r\n             * @param {ReactClass} publicInstance The instance that should rerender.\r\n             * @param {object} completeState Next state.\r\n             * @param {?function} callback Called after component is updated.\r\n             * @param {?string} callerName name of the calling function in the public API.\r\n             * @internal\r\n             */\r\n            enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\r\n                warnNoop(publicInstance, 'replaceState');\r\n            },\r\n            /**\r\n             * Sets a subset of the state. This only exists because _pendingState is\r\n             * internal. This provides a merging strategy that is not available to deep\r\n             * properties which is confusing. TODO: Expose pendingState or don't use it\r\n             * during the merge.\r\n             *\r\n             * @param {ReactClass} publicInstance The instance that should rerender.\r\n             * @param {object} partialState Next partial state to be merged with state.\r\n             * @param {?function} callback Called after component is updated.\r\n             * @param {?string} Name of the calling function in the public API.\r\n             * @internal\r\n             */\r\n            enqueueSetState: function (publicInstance, partialState, callback, callerName) {\r\n                warnNoop(publicInstance, 'setState');\r\n            }\r\n        };\r\n        /**\r\n         * Base class helpers for the updating state of a component.\r\n         */\r\n        function Component(props, context, updater) {\r\n            this.props = props;\r\n            this.context = context;\r\n            this.refs = emptyObject;\r\n            // We initialize the default updater but the real one gets injected by the\r\n            // renderer.\r\n            this.updater = updater || ReactNoopUpdateQueue;\r\n        }\r\n        Component.prototype.isReactComponent = {};\r\n        /**\r\n         * Sets a subset of the state. Always use this to mutate\r\n         * state. You should treat `this.state` as immutable.\r\n         *\r\n         * There is no guarantee that `this.state` will be immediately updated, so\r\n         * accessing `this.state` after calling this method may return the old value.\r\n         *\r\n         * There is no guarantee that calls to `setState` will run synchronously,\r\n         * as they may eventually be batched together.  You can provide an optional\r\n         * callback that will be executed when the call to setState is actually\r\n         * completed.\r\n         *\r\n         * When a function is provided to setState, it will be called at some point in\r\n         * the future (not synchronously). It will be called with the up to date\r\n         * component arguments (state, props, context). These values can be different\r\n         * from this.* because your function may be called after receiveProps but before\r\n         * shouldComponentUpdate, and this new state, props, and context will not yet be\r\n         * assigned to this.\r\n         *\r\n         * @param {object|function} partialState Next partial state or function to\r\n         *        produce next partial state to be merged with current state.\r\n         * @param {?function} callback Called after state is updated.\r\n         * @final\r\n         * @protected\r\n         */\r\n        Component.prototype.setState = function (partialState, callback) {\r\n            !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\r\n            this.updater.enqueueSetState(this, partialState, callback, 'setState');\r\n        };\r\n        /**\r\n         * Forces an update. This should only be invoked when it is known with\r\n         * certainty that we are **not** in a DOM transaction.\r\n         *\r\n         * You may want to call this when you know that some deeper aspect of the\r\n         * component's state has changed but `setState` was not called.\r\n         *\r\n         * This will not invoke `shouldComponentUpdate`, but it will invoke\r\n         * `componentWillUpdate` and `componentDidUpdate`.\r\n         *\r\n         * @param {?function} callback Called after update is complete.\r\n         * @final\r\n         * @protected\r\n         */\r\n        Component.prototype.forceUpdate = function (callback) {\r\n            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\r\n        };\r\n        /**\r\n         * Deprecated APIs. These APIs used to exist on classic React classes but since\r\n         * we would like to deprecate them, we're not going to move them over to this\r\n         * modern base class. Instead, we define a getter that warns if it's accessed.\r\n         */\r\n        {\r\n            var deprecatedAPIs = {\r\n                isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\r\n                replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\r\n            };\r\n            var defineDeprecationWarning = function (methodName, info) {\r\n                Object.defineProperty(Component.prototype, methodName, {\r\n                    get: function () {\r\n                        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\r\n                        return undefined;\r\n                    }\r\n                });\r\n            };\r\n            for (var fnName in deprecatedAPIs) {\r\n                if (deprecatedAPIs.hasOwnProperty(fnName)) {\r\n                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\r\n                }\r\n            }\r\n        }\r\n        function ComponentDummy() { }\r\n        ComponentDummy.prototype = Component.prototype;\r\n        /**\r\n         * Convenience component with default shallow equality check for sCU.\r\n         */\r\n        function PureComponent(props, context, updater) {\r\n            this.props = props;\r\n            this.context = context;\r\n            this.refs = emptyObject;\r\n            this.updater = updater || ReactNoopUpdateQueue;\r\n        }\r\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\r\n        pureComponentPrototype.constructor = PureComponent;\r\n        // Avoid an extra prototype jump for these methods.\r\n        _assign(pureComponentPrototype, Component.prototype);\r\n        pureComponentPrototype.isPureReactComponent = true;\r\n        // an immutable object with a single mutable value\r\n        function createRef() {\r\n            var refObject = {\r\n                current: null\r\n            };\r\n            {\r\n                Object.seal(refObject);\r\n            }\r\n            return refObject;\r\n        }\r\n        /**\r\n         * Keeps track of the current owner.\r\n         *\r\n         * The current owner is the component who should own any components that are\r\n         * currently being constructed.\r\n         */\r\n        var ReactCurrentOwner = {\r\n            /**\r\n             * @internal\r\n             * @type {ReactComponent}\r\n             */\r\n            current: null\r\n        };\r\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n        var RESERVED_PROPS = {\r\n            key: true,\r\n            ref: true,\r\n            __self: true,\r\n            __source: true\r\n        };\r\n        var specialPropKeyWarningShown = void 0;\r\n        var specialPropRefWarningShown = void 0;\r\n        function hasValidRef(config) {\r\n            {\r\n                if (hasOwnProperty.call(config, 'ref')) {\r\n                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\r\n                    if (getter && getter.isReactWarning) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return config.ref !== undefined;\r\n        }\r\n        function hasValidKey(config) {\r\n            {\r\n                if (hasOwnProperty.call(config, 'key')) {\r\n                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\r\n                    if (getter && getter.isReactWarning) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return config.key !== undefined;\r\n        }\r\n        function defineKeyPropWarningGetter(props, displayName) {\r\n            var warnAboutAccessingKey = function () {\r\n                if (!specialPropKeyWarningShown) {\r\n                    specialPropKeyWarningShown = true;\r\n                    warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\r\n                }\r\n            };\r\n            warnAboutAccessingKey.isReactWarning = true;\r\n            Object.defineProperty(props, 'key', {\r\n                get: warnAboutAccessingKey,\r\n                configurable: true\r\n            });\r\n        }\r\n        function defineRefPropWarningGetter(props, displayName) {\r\n            var warnAboutAccessingRef = function () {\r\n                if (!specialPropRefWarningShown) {\r\n                    specialPropRefWarningShown = true;\r\n                    warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\r\n                }\r\n            };\r\n            warnAboutAccessingRef.isReactWarning = true;\r\n            Object.defineProperty(props, 'ref', {\r\n                get: warnAboutAccessingRef,\r\n                configurable: true\r\n            });\r\n        }\r\n        /**\r\n         * Factory method to create a new React element. This no longer adheres to\r\n         * the class pattern, so do not use new to call it. Also, no instanceof check\r\n         * will work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n         * if something is a React Element.\r\n         *\r\n         * @param {*} type\r\n         * @param {*} key\r\n         * @param {string|object} ref\r\n         * @param {*} self A *temporary* helper to detect places where `this` is\r\n         * different from the `owner` when React.createElement is called, so that we\r\n         * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n         * functions, and as long as `this` and owner are the same, there will be no\r\n         * change in behavior.\r\n         * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n         * indicating filename, line number, and/or other information.\r\n         * @param {*} owner\r\n         * @param {*} props\r\n         * @internal\r\n         */\r\n        var ReactElement = function (type, key, ref, self, source, owner, props) {\r\n            var element = {\r\n                // This tag allows us to uniquely identify this as a React Element\r\n                $$typeof: REACT_ELEMENT_TYPE,\r\n                // Built-in properties that belong on the element\r\n                type: type,\r\n                key: key,\r\n                ref: ref,\r\n                props: props,\r\n                // Record the component responsible for creating this element.\r\n                _owner: owner\r\n            };\r\n            {\r\n                // The validation flag is currently mutative. We put it on\r\n                // an external backing store so that we can freeze the whole object.\r\n                // This can be replaced with a WeakMap once they are implemented in\r\n                // commonly used development environments.\r\n                element._store = {};\r\n                // To make comparing ReactElements easier for testing purposes, we make\r\n                // the validation flag non-enumerable (where possible, which should\r\n                // include every environment we run tests in), so the test framework\r\n                // ignores it.\r\n                Object.defineProperty(element._store, 'validated', {\r\n                    configurable: false,\r\n                    enumerable: false,\r\n                    writable: true,\r\n                    value: false\r\n                });\r\n                // self and source are DEV only properties.\r\n                Object.defineProperty(element, '_self', {\r\n                    configurable: false,\r\n                    enumerable: false,\r\n                    writable: false,\r\n                    value: self\r\n                });\r\n                // Two elements created in two different places should be considered\r\n                // equal for testing purposes and therefore we hide it from enumeration.\r\n                Object.defineProperty(element, '_source', {\r\n                    configurable: false,\r\n                    enumerable: false,\r\n                    writable: false,\r\n                    value: source\r\n                });\r\n                if (Object.freeze) {\r\n                    Object.freeze(element.props);\r\n                    Object.freeze(element);\r\n                }\r\n            }\r\n            return element;\r\n        };\r\n        /**\r\n         * Create and return a new ReactElement of the given type.\r\n         * See https://reactjs.org/docs/react-api.html#createelement\r\n         */\r\n        function createElement(type, config, children) {\r\n            var propName = void 0;\r\n            // Reserved names are extracted\r\n            var props = {};\r\n            var key = null;\r\n            var ref = null;\r\n            var self = null;\r\n            var source = null;\r\n            if (config != null) {\r\n                if (hasValidRef(config)) {\r\n                    ref = config.ref;\r\n                }\r\n                if (hasValidKey(config)) {\r\n                    key = '' + config.key;\r\n                }\r\n                self = config.__self === undefined ? null : config.__self;\r\n                source = config.__source === undefined ? null : config.__source;\r\n                // Remaining properties are added to a new props object\r\n                for (propName in config) {\r\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n                        props[propName] = config[propName];\r\n                    }\r\n                }\r\n            }\r\n            // Children can be more than one argument, and those are transferred onto\r\n            // the newly allocated props object.\r\n            var childrenLength = arguments.length - 2;\r\n            if (childrenLength === 1) {\r\n                props.children = children;\r\n            }\r\n            else if (childrenLength > 1) {\r\n                var childArray = Array(childrenLength);\r\n                for (var i = 0; i < childrenLength; i++) {\r\n                    childArray[i] = arguments[i + 2];\r\n                }\r\n                {\r\n                    if (Object.freeze) {\r\n                        Object.freeze(childArray);\r\n                    }\r\n                }\r\n                props.children = childArray;\r\n            }\r\n            // Resolve default props\r\n            if (type && type.defaultProps) {\r\n                var defaultProps = type.defaultProps;\r\n                for (propName in defaultProps) {\r\n                    if (props[propName] === undefined) {\r\n                        props[propName] = defaultProps[propName];\r\n                    }\r\n                }\r\n            }\r\n            {\r\n                if (key || ref) {\r\n                    if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\r\n                        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\r\n                        if (key) {\r\n                            defineKeyPropWarningGetter(props, displayName);\r\n                        }\r\n                        if (ref) {\r\n                            defineRefPropWarningGetter(props, displayName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n        }\r\n        /**\r\n         * Return a function that produces ReactElements of a given type.\r\n         * See https://reactjs.org/docs/react-api.html#createfactory\r\n         */\r\n        function cloneAndReplaceKey(oldElement, newKey) {\r\n            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\r\n            return newElement;\r\n        }\r\n        /**\r\n         * Clone and return a new ReactElement using element as the starting point.\r\n         * See https://reactjs.org/docs/react-api.html#cloneelement\r\n         */\r\n        function cloneElement(element, config, children) {\r\n            !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\r\n            var propName = void 0;\r\n            // Original props are copied\r\n            var props = _assign({}, element.props);\r\n            // Reserved names are extracted\r\n            var key = element.key;\r\n            var ref = element.ref;\r\n            // Self is preserved since the owner is preserved.\r\n            var self = element._self;\r\n            // Source is preserved since cloneElement is unlikely to be targeted by a\r\n            // transpiler, and the original source is probably a better indicator of the\r\n            // true owner.\r\n            var source = element._source;\r\n            // Owner will be preserved, unless ref is overridden\r\n            var owner = element._owner;\r\n            if (config != null) {\r\n                if (hasValidRef(config)) {\r\n                    // Silently steal the ref from the parent.\r\n                    ref = config.ref;\r\n                    owner = ReactCurrentOwner.current;\r\n                }\r\n                if (hasValidKey(config)) {\r\n                    key = '' + config.key;\r\n                }\r\n                // Remaining properties override existing props\r\n                var defaultProps = void 0;\r\n                if (element.type && element.type.defaultProps) {\r\n                    defaultProps = element.type.defaultProps;\r\n                }\r\n                for (propName in config) {\r\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n                        if (config[propName] === undefined && defaultProps !== undefined) {\r\n                            // Resolve default props\r\n                            props[propName] = defaultProps[propName];\r\n                        }\r\n                        else {\r\n                            props[propName] = config[propName];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Children can be more than one argument, and those are transferred onto\r\n            // the newly allocated props object.\r\n            var childrenLength = arguments.length - 2;\r\n            if (childrenLength === 1) {\r\n                props.children = children;\r\n            }\r\n            else if (childrenLength > 1) {\r\n                var childArray = Array(childrenLength);\r\n                for (var i = 0; i < childrenLength; i++) {\r\n                    childArray[i] = arguments[i + 2];\r\n                }\r\n                props.children = childArray;\r\n            }\r\n            return ReactElement(element.type, key, ref, self, source, owner, props);\r\n        }\r\n        /**\r\n         * Verifies the object is a ReactElement.\r\n         * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n         * @param {?object} object\r\n         * @return {boolean} True if `object` is a valid component.\r\n         * @final\r\n         */\r\n        function isValidElement(object) {\r\n            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n        }\r\n        var ReactDebugCurrentFrame = {};\r\n        {\r\n            // Component that is being worked on\r\n            ReactDebugCurrentFrame.getCurrentStack = null;\r\n            ReactDebugCurrentFrame.getStackAddendum = function () {\r\n                var impl = ReactDebugCurrentFrame.getCurrentStack;\r\n                if (impl) {\r\n                    return impl();\r\n                }\r\n                return null;\r\n            };\r\n        }\r\n        var SEPARATOR = '.';\r\n        var SUBSEPARATOR = ':';\r\n        /**\r\n         * Escape and wrap key so it is safe to use as a reactid\r\n         *\r\n         * @param {string} key to be escaped.\r\n         * @return {string} the escaped key.\r\n         */\r\n        function escape(key) {\r\n            var escapeRegex = /[=:]/g;\r\n            var escaperLookup = {\r\n                '=': '=0',\r\n                ':': '=2'\r\n            };\r\n            var escapedString = ('' + key).replace(escapeRegex, function (match) {\r\n                return escaperLookup[match];\r\n            });\r\n            return '$' + escapedString;\r\n        }\r\n        /**\r\n         * TODO: Test that a single child and an array with one item have the same key\r\n         * pattern.\r\n         */\r\n        var didWarnAboutMaps = false;\r\n        var userProvidedKeyEscapeRegex = /\\/+/g;\r\n        function escapeUserProvidedKey(text) {\r\n            return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\r\n        }\r\n        var POOL_SIZE = 10;\r\n        var traverseContextPool = [];\r\n        function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\r\n            if (traverseContextPool.length) {\r\n                var traverseContext = traverseContextPool.pop();\r\n                traverseContext.result = mapResult;\r\n                traverseContext.keyPrefix = keyPrefix;\r\n                traverseContext.func = mapFunction;\r\n                traverseContext.context = mapContext;\r\n                traverseContext.count = 0;\r\n                return traverseContext;\r\n            }\r\n            else {\r\n                return {\r\n                    result: mapResult,\r\n                    keyPrefix: keyPrefix,\r\n                    func: mapFunction,\r\n                    context: mapContext,\r\n                    count: 0\r\n                };\r\n            }\r\n        }\r\n        function releaseTraverseContext(traverseContext) {\r\n            traverseContext.result = null;\r\n            traverseContext.keyPrefix = null;\r\n            traverseContext.func = null;\r\n            traverseContext.context = null;\r\n            traverseContext.count = 0;\r\n            if (traverseContextPool.length < POOL_SIZE) {\r\n                traverseContextPool.push(traverseContext);\r\n            }\r\n        }\r\n        /**\r\n         * @param {?*} children Children tree container.\r\n         * @param {!string} nameSoFar Name of the key path so far.\r\n         * @param {!function} callback Callback to invoke with each child found.\r\n         * @param {?*} traverseContext Used to pass information throughout the traversal\r\n         * process.\r\n         * @return {!number} The number of children in this subtree.\r\n         */\r\n        function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\r\n            var type = typeof children;\r\n            if (type === 'undefined' || type === 'boolean') {\r\n                // All of the above are perceived as null.\r\n                children = null;\r\n            }\r\n            var invokeCallback = false;\r\n            if (children === null) {\r\n                invokeCallback = true;\r\n            }\r\n            else {\r\n                switch (type) {\r\n                    case 'string':\r\n                    case 'number':\r\n                        invokeCallback = true;\r\n                        break;\r\n                    case 'object':\r\n                        switch (children.$$typeof) {\r\n                            case REACT_ELEMENT_TYPE:\r\n                            case REACT_PORTAL_TYPE:\r\n                                invokeCallback = true;\r\n                        }\r\n                }\r\n            }\r\n            if (invokeCallback) {\r\n                callback(traverseContext, children, \r\n                // If it's the only child, treat the name as if it was wrapped in an array\r\n                // so that it's consistent if the number of children grows.\r\n                nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\r\n                return 1;\r\n            }\r\n            var child = void 0;\r\n            var nextName = void 0;\r\n            var subtreeCount = 0; // Count of children found in the current subtree.\r\n            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\r\n            if (Array.isArray(children)) {\r\n                for (var i = 0; i < children.length; i++) {\r\n                    child = children[i];\r\n                    nextName = nextNamePrefix + getComponentKey(child, i);\r\n                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\r\n                }\r\n            }\r\n            else {\r\n                var iteratorFn = getIteratorFn(children);\r\n                if (typeof iteratorFn === 'function') {\r\n                    {\r\n                        // Warn about using Maps as children\r\n                        if (iteratorFn === children.entries) {\r\n                            !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;\r\n                            didWarnAboutMaps = true;\r\n                        }\r\n                    }\r\n                    var iterator = iteratorFn.call(children);\r\n                    var step = void 0;\r\n                    var ii = 0;\r\n                    while (!(step = iterator.next()).done) {\r\n                        child = step.value;\r\n                        nextName = nextNamePrefix + getComponentKey(child, ii++);\r\n                        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\r\n                    }\r\n                }\r\n                else if (type === 'object') {\r\n                    var addendum = '';\r\n                    {\r\n                        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\r\n                    }\r\n                    var childrenString = '' + children;\r\n                    invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\r\n                }\r\n            }\r\n            return subtreeCount;\r\n        }\r\n        /**\r\n         * Traverses children that are typically specified as `props.children`, but\r\n         * might also be specified through attributes:\r\n         *\r\n         * - `traverseAllChildren(this.props.children, ...)`\r\n         * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\r\n         *\r\n         * The `traverseContext` is an optional argument that is passed through the\r\n         * entire traversal. It can be used to store accumulations or anything else that\r\n         * the callback might find relevant.\r\n         *\r\n         * @param {?*} children Children tree object.\r\n         * @param {!function} callback To invoke upon traversing each child.\r\n         * @param {?*} traverseContext Context for traversal.\r\n         * @return {!number} The number of children in this subtree.\r\n         */\r\n        function traverseAllChildren(children, callback, traverseContext) {\r\n            if (children == null) {\r\n                return 0;\r\n            }\r\n            return traverseAllChildrenImpl(children, '', callback, traverseContext);\r\n        }\r\n        /**\r\n         * Generate a key string that identifies a component within a set.\r\n         *\r\n         * @param {*} component A component that could contain a manual key.\r\n         * @param {number} index Index that is used if a manual key is not provided.\r\n         * @return {string}\r\n         */\r\n        function getComponentKey(component, index) {\r\n            // Do some typechecking here since we call this blindly. We want to ensure\r\n            // that we don't block potential future ES APIs.\r\n            if (typeof component === 'object' && component !== null && component.key != null) {\r\n                // Explicit key\r\n                return escape(component.key);\r\n            }\r\n            // Implicit key determined by the index in the set\r\n            return index.toString(36);\r\n        }\r\n        function forEachSingleChild(bookKeeping, child, name) {\r\n            var func = bookKeeping.func, context = bookKeeping.context;\r\n            func.call(context, child, bookKeeping.count++);\r\n        }\r\n        /**\r\n         * Iterates through children that are typically specified as `props.children`.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#react.children.foreach\r\n         *\r\n         * The provided forEachFunc(child, index) will be called for each\r\n         * leaf child.\r\n         *\r\n         * @param {?*} children Children tree container.\r\n         * @param {function(*, int)} forEachFunc\r\n         * @param {*} forEachContext Context for forEachContext.\r\n         */\r\n        function forEachChildren(children, forEachFunc, forEachContext) {\r\n            if (children == null) {\r\n                return children;\r\n            }\r\n            var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\r\n            traverseAllChildren(children, forEachSingleChild, traverseContext);\r\n            releaseTraverseContext(traverseContext);\r\n        }\r\n        function mapSingleChildIntoContext(bookKeeping, child, childKey) {\r\n            var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;\r\n            var mappedChild = func.call(context, child, bookKeeping.count++);\r\n            if (Array.isArray(mappedChild)) {\r\n                mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\r\n            }\r\n            else if (mappedChild != null) {\r\n                if (isValidElement(mappedChild)) {\r\n                    mappedChild = cloneAndReplaceKey(mappedChild, \r\n                    // Keep both the (mapped) and old keys if they differ, just as\r\n                    // traverseAllChildren used to do for objects as children\r\n                    keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\r\n                }\r\n                result.push(mappedChild);\r\n            }\r\n        }\r\n        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\r\n            var escapedPrefix = '';\r\n            if (prefix != null) {\r\n                escapedPrefix = escapeUserProvidedKey(prefix) + '/';\r\n            }\r\n            var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\r\n            traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\r\n            releaseTraverseContext(traverseContext);\r\n        }\r\n        /**\r\n         * Maps children that are typically specified as `props.children`.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#react.children.map\r\n         *\r\n         * The provided mapFunction(child, key, index) will be called for each\r\n         * leaf child.\r\n         *\r\n         * @param {?*} children Children tree container.\r\n         * @param {function(*, int)} func The map function.\r\n         * @param {*} context Context for mapFunction.\r\n         * @return {object} Object containing the ordered map of results.\r\n         */\r\n        function mapChildren(children, func, context) {\r\n            if (children == null) {\r\n                return children;\r\n            }\r\n            var result = [];\r\n            mapIntoWithKeyPrefixInternal(children, result, null, func, context);\r\n            return result;\r\n        }\r\n        /**\r\n         * Count the number of children that are typically specified as\r\n         * `props.children`.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#react.children.count\r\n         *\r\n         * @param {?*} children Children tree container.\r\n         * @return {number} The number of children.\r\n         */\r\n        function countChildren(children) {\r\n            return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\r\n        }\r\n        /**\r\n         * Flatten a children object (typically specified as `props.children`) and\r\n         * return an array with appropriately re-keyed children.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#react.children.toarray\r\n         */\r\n        function toArray(children) {\r\n            var result = [];\r\n            mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\r\n            return result;\r\n        }\r\n        /**\r\n         * Returns the first child in a collection of children and verifies that there\r\n         * is only one child in the collection.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#react.children.only\r\n         *\r\n         * The current implementation of this function assumes that a single child gets\r\n         * passed without a wrapper, but the purpose of this helper function is to\r\n         * abstract away the particular structure of children.\r\n         *\r\n         * @param {?object} children Child collection structure.\r\n         * @return {ReactElement} The first and only `ReactElement` contained in the\r\n         * structure.\r\n         */\r\n        function onlyChild(children) {\r\n            !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\r\n            return children;\r\n        }\r\n        function createContext(defaultValue, calculateChangedBits) {\r\n            if (calculateChangedBits === undefined) {\r\n                calculateChangedBits = null;\r\n            }\r\n            else {\r\n                {\r\n                    !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\r\n                }\r\n            }\r\n            var context = {\r\n                $$typeof: REACT_CONTEXT_TYPE,\r\n                _calculateChangedBits: calculateChangedBits,\r\n                _defaultValue: defaultValue,\r\n                _currentValue: defaultValue,\r\n                // As a workaround to support multiple concurrent renderers, we categorize\r\n                // some renderers as primary and others as secondary. We only expect\r\n                // there to be two concurrent renderers at most: React Native (primary) and\r\n                // Fabric (secondary); React DOM (primary) and React ART (secondary).\r\n                // Secondary renderers store their context values on separate fields.\r\n                _currentValue2: defaultValue,\r\n                _changedBits: 0,\r\n                _changedBits2: 0,\r\n                // These are circular\r\n                Provider: null,\r\n                Consumer: null\r\n            };\r\n            context.Provider = {\r\n                $$typeof: REACT_PROVIDER_TYPE,\r\n                _context: context\r\n            };\r\n            context.Consumer = context;\r\n            {\r\n                context._currentRenderer = null;\r\n                context._currentRenderer2 = null;\r\n            }\r\n            return context;\r\n        }\r\n        function forwardRef(render) {\r\n            {\r\n                !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render) : void 0;\r\n                if (render != null) {\r\n                    !(render.defaultProps == null && render.propTypes == null) ? warning(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;\r\n                }\r\n            }\r\n            return {\r\n                $$typeof: REACT_FORWARD_REF_TYPE,\r\n                render: render\r\n            };\r\n        }\r\n        var describeComponentFrame = function (name, source, ownerName) {\r\n            return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\r\n        };\r\n        function isValidElementType(type) {\r\n            return typeof type === 'string' || typeof type === 'function' ||\r\n                // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\r\n                type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_TIMEOUT_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\r\n        }\r\n        function getComponentName(fiber) {\r\n            var type = fiber.type;\r\n            if (typeof type === 'function') {\r\n                return type.displayName || type.name;\r\n            }\r\n            if (typeof type === 'string') {\r\n                return type;\r\n            }\r\n            switch (type) {\r\n                case REACT_ASYNC_MODE_TYPE:\r\n                    return 'AsyncMode';\r\n                case REACT_CONTEXT_TYPE:\r\n                    return 'Context.Consumer';\r\n                case REACT_FRAGMENT_TYPE:\r\n                    return 'ReactFragment';\r\n                case REACT_PORTAL_TYPE:\r\n                    return 'ReactPortal';\r\n                case REACT_PROFILER_TYPE:\r\n                    return 'Profiler(' + fiber.pendingProps.id + ')';\r\n                case REACT_PROVIDER_TYPE:\r\n                    return 'Context.Provider';\r\n                case REACT_STRICT_MODE_TYPE:\r\n                    return 'StrictMode';\r\n                case REACT_TIMEOUT_TYPE:\r\n                    return 'Timeout';\r\n            }\r\n            if (typeof type === 'object' && type !== null) {\r\n                switch (type.$$typeof) {\r\n                    case REACT_FORWARD_REF_TYPE:\r\n                        var functionName = type.render.displayName || type.render.name || '';\r\n                        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * ReactElementValidator provides a wrapper around a element factory\r\n         * which validates the props passed to the element. This is intended to be\r\n         * used only in DEV and could be replaced by a static type checker for languages\r\n         * that support it.\r\n         */\r\n        var currentlyValidatingElement = void 0;\r\n        var propTypesMisspellWarningShown = void 0;\r\n        var getDisplayName = function () { };\r\n        var getStackAddendum = function () { };\r\n        {\r\n            currentlyValidatingElement = null;\r\n            propTypesMisspellWarningShown = false;\r\n            getDisplayName = function (element) {\r\n                if (element == null) {\r\n                    return '#empty';\r\n                }\r\n                else if (typeof element === 'string' || typeof element === 'number') {\r\n                    return '#text';\r\n                }\r\n                else if (typeof element.type === 'string') {\r\n                    return element.type;\r\n                }\r\n                else if (element.type === REACT_FRAGMENT_TYPE) {\r\n                    return 'React.Fragment';\r\n                }\r\n                else {\r\n                    return element.type.displayName || element.type.name || 'Unknown';\r\n                }\r\n            };\r\n            getStackAddendum = function () {\r\n                var stack = '';\r\n                if (currentlyValidatingElement) {\r\n                    var name = getDisplayName(currentlyValidatingElement);\r\n                    var owner = currentlyValidatingElement._owner;\r\n                    stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\r\n                }\r\n                stack += ReactDebugCurrentFrame.getStackAddendum() || '';\r\n                return stack;\r\n            };\r\n        }\r\n        function getDeclarationErrorAddendum() {\r\n            if (ReactCurrentOwner.current) {\r\n                var name = getComponentName(ReactCurrentOwner.current);\r\n                if (name) {\r\n                    return '\\n\\nCheck the render method of `' + name + '`.';\r\n                }\r\n            }\r\n            return '';\r\n        }\r\n        function getSourceInfoErrorAddendum(elementProps) {\r\n            if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\r\n                var source = elementProps.__source;\r\n                var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\r\n                var lineNumber = source.lineNumber;\r\n                return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\r\n            }\r\n            return '';\r\n        }\r\n        /**\r\n         * Warn if there's no key explicitly set on dynamic arrays of children or\r\n         * object keys are not valid. This allows us to keep track of children between\r\n         * updates.\r\n         */\r\n        var ownerHasKeyUseWarning = {};\r\n        function getCurrentComponentErrorInfo(parentType) {\r\n            var info = getDeclarationErrorAddendum();\r\n            if (!info) {\r\n                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\r\n                if (parentName) {\r\n                    info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\r\n                }\r\n            }\r\n            return info;\r\n        }\r\n        /**\r\n         * Warn if the element doesn't have an explicit key assigned to it.\r\n         * This element is in an array. The array could grow and shrink or be\r\n         * reordered. All children that haven't already been validated are required to\r\n         * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n         * will only be shown once.\r\n         *\r\n         * @internal\r\n         * @param {ReactElement} element Element that requires a key.\r\n         * @param {*} parentType element's parent's type.\r\n         */\r\n        function validateExplicitKey(element, parentType) {\r\n            if (!element._store || element._store.validated || element.key != null) {\r\n                return;\r\n            }\r\n            element._store.validated = true;\r\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n                return;\r\n            }\r\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\r\n            // Usually the current owner is the offender, but if it accepts children as a\r\n            // property, it may be the creator of the child that's responsible for\r\n            // assigning it a key.\r\n            var childOwner = '';\r\n            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\r\n                // Give the component that originally created this child.\r\n                childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\r\n            }\r\n            currentlyValidatingElement = element;\r\n            {\r\n                warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\r\n            }\r\n            currentlyValidatingElement = null;\r\n        }\r\n        /**\r\n         * Ensure that every element either is passed in a static location, in an\r\n         * array with an explicit keys property defined, or in an object literal\r\n         * with valid key property.\r\n         *\r\n         * @internal\r\n         * @param {ReactNode} node Statically passed child of any type.\r\n         * @param {*} parentType node's parent's type.\r\n         */\r\n        function validateChildKeys(node, parentType) {\r\n            if (typeof node !== 'object') {\r\n                return;\r\n            }\r\n            if (Array.isArray(node)) {\r\n                for (var i = 0; i < node.length; i++) {\r\n                    var child = node[i];\r\n                    if (isValidElement(child)) {\r\n                        validateExplicitKey(child, parentType);\r\n                    }\r\n                }\r\n            }\r\n            else if (isValidElement(node)) {\r\n                // This element was passed in a valid location.\r\n                if (node._store) {\r\n                    node._store.validated = true;\r\n                }\r\n            }\r\n            else if (node) {\r\n                var iteratorFn = getIteratorFn(node);\r\n                if (typeof iteratorFn === 'function') {\r\n                    // Entry iterators used to provide implicit keys,\r\n                    // but now we print a separate warning for them later.\r\n                    if (iteratorFn !== node.entries) {\r\n                        var iterator = iteratorFn.call(node);\r\n                        var step = void 0;\r\n                        while (!(step = iterator.next()).done) {\r\n                            if (isValidElement(step.value)) {\r\n                                validateExplicitKey(step.value, parentType);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Given an element, validate that its props follow the propTypes definition,\r\n         * provided by the type.\r\n         *\r\n         * @param {ReactElement} element\r\n         */\r\n        function validatePropTypes(element) {\r\n            var componentClass = element.type;\r\n            if (typeof componentClass !== 'function') {\r\n                return;\r\n            }\r\n            var name = componentClass.displayName || componentClass.name;\r\n            var propTypes = componentClass.propTypes;\r\n            if (propTypes) {\r\n                currentlyValidatingElement = element;\r\n                checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\r\n                currentlyValidatingElement = null;\r\n            }\r\n            else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\r\n                propTypesMisspellWarningShown = true;\r\n                warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\r\n            }\r\n            if (typeof componentClass.getDefaultProps === 'function') {\r\n                !componentClass.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\r\n            }\r\n        }\r\n        /**\r\n         * Given a fragment, validate that it can only be provided with fragment props\r\n         * @param {ReactElement} fragment\r\n         */\r\n        function validateFragmentProps(fragment) {\r\n            currentlyValidatingElement = fragment;\r\n            var keys = Object.keys(fragment.props);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var key = keys[i];\r\n                if (key !== 'children' && key !== 'key') {\r\n                    warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\r\n                    break;\r\n                }\r\n            }\r\n            if (fragment.ref !== null) {\r\n                warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\r\n            }\r\n            currentlyValidatingElement = null;\r\n        }\r\n        function createElementWithValidation(type, props, children) {\r\n            var validType = isValidElementType(type);\r\n            // We warn in this case but don't throw. We expect the element creation to\r\n            // succeed and there will likely be errors in render.\r\n            if (!validType) {\r\n                var info = '';\r\n                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\r\n                }\r\n                var sourceInfo = getSourceInfoErrorAddendum(props);\r\n                if (sourceInfo) {\r\n                    info += sourceInfo;\r\n                }\r\n                else {\r\n                    info += getDeclarationErrorAddendum();\r\n                }\r\n                info += getStackAddendum() || '';\r\n                var typeString = void 0;\r\n                if (type === null) {\r\n                    typeString = 'null';\r\n                }\r\n                else if (Array.isArray(type)) {\r\n                    typeString = 'array';\r\n                }\r\n                else {\r\n                    typeString = typeof type;\r\n                }\r\n                warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\r\n            }\r\n            var element = createElement.apply(this, arguments);\r\n            // The result can be nullish if a mock or a custom function is used.\r\n            // TODO: Drop this when these are no longer allowed as the type argument.\r\n            if (element == null) {\r\n                return element;\r\n            }\r\n            // Skip key warning if the type isn't valid since our key validation logic\r\n            // doesn't expect a non-string/function type and can throw confusing errors.\r\n            // We don't want exception behavior to differ between dev and prod.\r\n            // (Rendering will throw with a helpful message and as soon as the type is\r\n            // fixed, the key warnings will appear.)\r\n            if (validType) {\r\n                for (var i = 2; i < arguments.length; i++) {\r\n                    validateChildKeys(arguments[i], type);\r\n                }\r\n            }\r\n            if (type === REACT_FRAGMENT_TYPE) {\r\n                validateFragmentProps(element);\r\n            }\r\n            else {\r\n                validatePropTypes(element);\r\n            }\r\n            return element;\r\n        }\r\n        function createFactoryWithValidation(type) {\r\n            var validatedFactory = createElementWithValidation.bind(null, type);\r\n            validatedFactory.type = type;\r\n            // Legacy hook: remove it\r\n            {\r\n                Object.defineProperty(validatedFactory, 'type', {\r\n                    enumerable: false,\r\n                    get: function () {\r\n                        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\r\n                        Object.defineProperty(this, 'type', {\r\n                            value: type\r\n                        });\r\n                        return type;\r\n                    }\r\n                });\r\n            }\r\n            return validatedFactory;\r\n        }\r\n        function cloneElementWithValidation(element, props, children) {\r\n            var newElement = cloneElement.apply(this, arguments);\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                validateChildKeys(arguments[i], newElement.type);\r\n            }\r\n            validatePropTypes(newElement);\r\n            return newElement;\r\n        }\r\n        var React = {\r\n            Children: {\r\n                map: mapChildren,\r\n                forEach: forEachChildren,\r\n                count: countChildren,\r\n                toArray: toArray,\r\n                only: onlyChild\r\n            },\r\n            createRef: createRef,\r\n            Component: Component,\r\n            PureComponent: PureComponent,\r\n            createContext: createContext,\r\n            forwardRef: forwardRef,\r\n            Fragment: REACT_FRAGMENT_TYPE,\r\n            StrictMode: REACT_STRICT_MODE_TYPE,\r\n            unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\r\n            unstable_Profiler: REACT_PROFILER_TYPE,\r\n            createElement: createElementWithValidation,\r\n            cloneElement: cloneElementWithValidation,\r\n            createFactory: createFactoryWithValidation,\r\n            isValidElement: isValidElement,\r\n            version: ReactVersion,\r\n            __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\r\n                ReactCurrentOwner: ReactCurrentOwner,\r\n                // Used by renderers to avoid bundling object-assign twice in UMD bundles:\r\n                assign: _assign\r\n            }\r\n        };\r\n        if (enableSuspense) {\r\n            React.Timeout = REACT_TIMEOUT_TYPE;\r\n        }\r\n        {\r\n            _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\r\n                // These should not be included in production.\r\n                ReactDebugCurrentFrame: ReactDebugCurrentFrame,\r\n                // Shim for React DOM 16.0.0 which still destructured (but not used) this.\r\n                // TODO: remove in React 17.0.\r\n                ReactComponentTreeHook: {}\r\n            });\r\n        }\r\n        var React$2 = Object.freeze({\r\n            default: React\r\n        });\r\n        var React$3 = (React$2 && React) || React$2;\r\n        // TODO: decide on the top-level export form.\r\n        // This is hacky but makes it work with both Rollup and Jest.\r\n        var react = React$3.default ? React$3.default : React$3;\r\n        module.exports = react;\r\n    })();\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nif (false) {}\r\nelse {\r\n    module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/react/index.js?");

/***/ }),

/***/ "./src/CollectorComponent/CollectorComponent.jsx":
/*!*******************************************************!*\
  !*** ./src/CollectorComponent/CollectorComponent.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\nvar PropTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\r\nvar PuppeteerTestGenerator_1 = __webpack_require__(/*! ../client/PuppeteerTestGenerator */ \"./src/client/PuppeteerTestGenerator.ts\");\r\nvar ToggleCollapseIcon_1 = __webpack_require__(/*! ./ToggleCollapseIcon */ \"./src/CollectorComponent/ToggleCollapseIcon.jsx\");\r\nvar Statuses = {\r\n    None: 'none',\r\n    Generating: 'generating',\r\n    Success: 'success'\r\n};\r\nvar CollectorComponent = /** @class */ (function (_super) {\r\n    __extends(CollectorComponent, _super);\r\n    function CollectorComponent(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.onMouseDown = function (e) {\r\n            var root = _this.root;\r\n            var startClientX = null;\r\n            var startClientY = null;\r\n            var startRight = 0;\r\n            var startTop = 0;\r\n            moveAt(e, true);\r\n            function moveAt(e, first) {\r\n                if (first === void 0) { first = false; }\r\n                if (first) {\r\n                    startClientX = e.clientX;\r\n                    startClientY = e.clientY;\r\n                    startRight = parseInt(root.style.right);\r\n                    startTop = parseInt(root.style.top);\r\n                    return;\r\n                }\r\n                var computedRight = startRight + (startClientX - e.clientX);\r\n                if (computedRight >= 0) {\r\n                    root.style.right = computedRight + 'px';\r\n                }\r\n                var computedTop = startTop + (e.clientY - startClientY);\r\n                if (computedTop >= 0) {\r\n                    root.style.top = computedTop + 'px';\r\n                }\r\n            }\r\n            var mouseMoveEventListener = function (e) {\r\n                if (e.preventDefault)\r\n                    e.preventDefault();\r\n                moveAt(e);\r\n            };\r\n            document.addEventListener('mousemove', mouseMoveEventListener);\r\n            document.addEventListener('mouseup', function mouseUpEventListener() {\r\n                document.removeEventListener('mouseup', mouseUpEventListener);\r\n                document.removeEventListener('mousemove', mouseMoveEventListener);\r\n            });\r\n        };\r\n        _this.onFinishBtnClick = function () {\r\n            _this.setState({ status: Statuses.Generating });\r\n            _this.state.generator\r\n                .finish()\r\n                .then(function () {\r\n                _this.setState({ status: Statuses.Success });\r\n            })\r\n                .catch(function (res) {\r\n                /* eslint-disable no-console */\r\n                if (res.stack) {\r\n                    console.error(res.stack);\r\n                }\r\n                /* eslint-enable no-console */\r\n                _this.setState({\r\n                    error: res.message ? _this.handleError(res.message) : res.status,\r\n                    status: Statuses.None\r\n                });\r\n            });\r\n        };\r\n        _this.handleError = function (errorMsg) {\r\n            return errorMsg.replace(/\\n/g, '<br />');\r\n        };\r\n        var errorsArray = [];\r\n        errorsArray.push = function (element) {\r\n            _this.setState({ error: element, collapsed: false });\r\n        };\r\n        _this.state = {\r\n            generator: new PuppeteerTestGenerator_1.default({\r\n                testsFolder: props.testsFolder,\r\n                saveToFs: props.saveToFs,\r\n                addComments: props.addComments,\r\n                indicatorQuerySelector: '[data-flashtest-hook=\"___FLASHTEST-INDICATOR\"]',\r\n                errorsArray: errorsArray\r\n            }),\r\n            error: undefined,\r\n            success: false,\r\n            moveable: false,\r\n            collapsed: false,\r\n            status: Statuses.None\r\n        };\r\n        _this.state.generator.start();\r\n        return _this;\r\n    }\r\n    CollectorComponent.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.state, error = _a.error, status = _a.status;\r\n        return (React.createElement(\"div\", null,\r\n            this.props.children,\r\n            React.createElement(\"div\", { ref: function (el) { return (_this.root = el); }, style: {\r\n                    position: 'fixed',\r\n                    right: '0px',\r\n                    top: '0px',\r\n                    zIndex: 10000,\r\n                    display: 'flex',\r\n                    flexDirection: 'column'\r\n                } },\r\n                React.createElement(\"div\", { style: {\r\n                        display: 'flex',\r\n                        boxShadow: '0 2px 5px 2px rgba(65,36,75,.1)',\r\n                        border: '1px solid #a6a6a6',\r\n                        borderBottom: 'none',\r\n                        height: '26px',\r\n                        width: '51px',\r\n                        boxSizing: 'border-box',\r\n                        background: 'white',\r\n                        alignSelf: 'flex-end'\r\n                    } },\r\n                    React.createElement(\"div\", { style: { padding: '2px', borderRight: '1px solid #a6a6a6', cursor: 'pointer' }, onMouseDown: this.onMouseDown },\r\n                        React.createElement(\"svg\", { width: \"20px\", height: \"20px\", viewBox: \"0 0 16 16\" },\r\n                            React.createElement(\"path\", { fill: \"#0a6a6a\", d: \"M16 8l-3-3v2h-4v-4h2l-3-3-3 3h2v4h-4v-2l-3 3 3 3v-2h4v4h-2l3 3 3-3h-2v-4h4v2z\" }))),\r\n                    React.createElement(\"div\", { style: { padding: '2px', cursor: 'pointer' } },\r\n                        React.createElement(ToggleCollapseIcon_1.default, { collapsed: this.state.collapsed, onCollapseToggle: function (collapsed) { return _this.setState({ collapsed: collapsed }); } }))),\r\n                !this.state.collapsed && (React.createElement(\"div\", { style: {\r\n                        boxSizing: 'border-box',\r\n                        display: 'flex',\r\n                        flexDirection: 'column',\r\n                        justifyContent: 'space-between',\r\n                        background: 'white',\r\n                        padding: '10px',\r\n                        width: '300px',\r\n                        boxShadow: '0 2px 5px 2px rgba(65,36,75,.1)',\r\n                        border: '1px solid #a6a6a6'\r\n                    } },\r\n                    status === Statuses.Generating && React.createElement(\"div\", null, \"Generating...\"),\r\n                    status === Statuses.Success && React.createElement(\"div\", null, \"Test successfully saved\"),\r\n                    status === Statuses.None && (React.createElement(\"div\", { style: { display: 'flex', justifyContent: 'space-between' } },\r\n                        React.createElement(\"button\", { onClick: this.onFinishBtnClick, \"data-flashtest-hook\": \"___FLASHTEST-FINISH-BUTTON\", style: {\r\n                                width: '100px',\r\n                                height: '32px',\r\n                                border: 'none',\r\n                                background: '#a6a6a6',\r\n                                color: 'white',\r\n                                cursor: 'pointer',\r\n                                outline: 'none'\r\n                            } }, \"Finish Test\"))),\r\n                    error && (React.createElement(\"div\", { style: {\r\n                            marginTop: '10px',\r\n                            border: 'none',\r\n                            padding: '4px',\r\n                            fontSize: '15px'\r\n                        }, dangerouslySetInnerHTML: { __html: error } })))),\r\n                React.createElement(\"div\", { style: {\r\n                        background: 'green',\r\n                        width: this.state.collapsed ? '51px' : '100%',\r\n                        height: '8px'\r\n                    }, \"data-flashtest-hook\": \"___FLASHTEST-INDICATOR\" }))));\r\n    };\r\n    CollectorComponent.defaultProps = {\r\n        saveToFs: false,\r\n        addComments: true\r\n    };\r\n    return CollectorComponent;\r\n}(React.Component));\r\nCollectorComponent.propTypes = {\r\n    saveToFs: PropTypes.bool,\r\n    testsFolder: PropTypes.string.isRequired,\r\n    addComments: PropTypes.bool\r\n};\r\nexports.default = CollectorComponent;\r\n\n\n//# sourceURL=webpack:///./src/CollectorComponent/CollectorComponent.jsx?");

/***/ }),

/***/ "./src/CollectorComponent/ToggleCollapseIcon.jsx":
/*!*******************************************************!*\
  !*** ./src/CollectorComponent/ToggleCollapseIcon.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\nvar PropTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\r\nvar ToggleCollapseIcon = /** @class */ (function (_super) {\r\n    __extends(ToggleCollapseIcon, _super);\r\n    function ToggleCollapseIcon() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ToggleCollapseIcon.prototype.render = function () {\r\n        var _this = this;\r\n        return this.props.collapsed ? (React.createElement(\"svg\", { width: \"20px\", height: \"20px\", viewBox: \"0 0 612 612\", onClick: function () { return _this.props.onCollapseToggle(false); } },\r\n            React.createElement(\"g\", null,\r\n                React.createElement(\"g\", { id: \"_x36_\" },\r\n                    React.createElement(\"g\", null,\r\n                        React.createElement(\"path\", { xmlns: \"http://www.w3.org/2000/svg\", d: \"M210.498,344.459L90.804,466.526l-41.742-41.742c-9.034-9.033-18.201-18.641-29.129-18.66     c-10.928-0.019-19.77,8.823-19.751,19.751l0.229,165.034c0,5.837,2.641,10.928,6.661,14.564c3.636,4.019,8.746,6.641,14.564,6.66     l165.053,0.229c10.928,0.02,19.77-8.823,19.751-19.751c-0.019-10.929-12.766-23.216-18.239-28.689l-41.742-41.741     l121.455-120.307L210.498,344.459z M611.952,21.952c0-5.972-2.68-11.196-6.775-14.909c-3.693-4.115-8.88-6.794-14.813-6.813     L422.536,0c-11.101-0.02-20.096,9.033-20.096,20.21c0.019,11.177,12.976,23.77,18.545,29.359l42.45,42.718L344.469,210.469     l57.416,57.416l118.144-118.641l42.45,42.718c9.187,9.244,18.507,19.082,29.607,19.101c11.12,0.019,20.096-9.034,20.096-20.21     L611.952,21.952z\", fill: \"#0a6a6a\" })))))) : (React.createElement(\"svg\", { width: \"20px\", height: \"20px\", viewBox: \"0 0 612 612\", onClick: function () { return _this.props.onCollapseToggle(true); } },\r\n            React.createElement(\"g\", null,\r\n                React.createElement(\"g\", { id: \"_x36_\" },\r\n                    React.createElement(\"g\", null,\r\n                        React.createElement(\"path\", { d: \"M260.655,351.173c-3.615-4.016-8.721-6.636-14.554-6.655l-164.915-0.229c-10.92-0.019-19.756,8.816-19.737,19.737     c0.019,10.92,12.756,23.198,18.226,28.668l41.711,41.712L0,554.625L57.375,612l119.608-121.979l41.711,41.712     c9.027,9.027,18.188,18.628,29.108,18.646c10.92,0.02,19.756-8.816,19.737-19.736l-0.229-164.915     C267.291,359.895,264.671,354.788,260.655,351.173z M493.119,175.472L612,57.375L554.625,0L436.566,118.556l-42.419-42.687     c-9.181-9.238-18.494-19.068-29.587-19.087c-11.111-0.019-20.081,9.027-20.081,20.196l0.229,168.797     c0,5.967,2.678,11.188,6.771,14.898c3.69,4.112,8.874,6.789,14.803,6.809l167.726,0.229c11.093,0.019,20.082-9.027,20.082-20.196     c-0.02-11.169-12.967-23.753-18.532-29.338L493.119,175.472z\", fill: \"#0a6a6a\" }))))));\r\n    };\r\n    return ToggleCollapseIcon;\r\n}(React.Component));\r\nToggleCollapseIcon.propTypes = {\r\n    collapsed: PropTypes.bool.isRequired,\r\n    onCollapseToggle: PropTypes.func.isRequired\r\n};\r\nexports.default = ToggleCollapseIcon;\r\n\n\n//# sourceURL=webpack:///./src/CollectorComponent/ToggleCollapseIcon.jsx?");

/***/ }),

/***/ "./src/Console.ts":
/*!************************!*\
  !*** ./src/Console.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* eslint-disable no-console*/\r\nvar Console = /** @class */ (function () {\r\n    function Console() {\r\n    }\r\n    Console.log = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (false)\r\n            {}\r\n    };\r\n    Console.warn = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (false)\r\n            {}\r\n    };\r\n    Console.error = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (false)\r\n            {}\r\n    };\r\n    Console.group = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (false)\r\n            {}\r\n    };\r\n    Console.groupEnd = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (false)\r\n            {}\r\n    };\r\n    return Console;\r\n}());\r\nexports.default = Console;\r\n\n\n//# sourceURL=webpack:///./src/Console.ts?");

/***/ }),

/***/ "./src/client/ActionsHandler.ts":
/*!**************************************!*\
  !*** ./src/client/ActionsHandler.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Console_1 = __webpack_require__(/*! ../Console */ \"./src/Console.ts\");\r\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./src/client/helper.ts\");\r\n/**\r\n * This handler handle actions, prepare them for test generating.\r\n *\r\n * TODO: It is very badly implemented, it should be refactored when most cases will be known\r\n * and all events will be handled.\r\n * These cases will be known after feedback from community or using this library on very big project\r\n *\r\n * TODO: more likely returning to chunks with EndRequestAction should be done.\r\n * Because it is hard to handle some cases and code is messed. For example:\r\n * - first input triggered adding of DOM node,\r\n * - second input triggered removing of DOM node.\r\n * In this case we don't need to merge these two inputs\r\n * To implement this handling for one actions array we need to create some workarounds and hacks.\r\n * Handling isn't clear.\r\n */\r\nvar ActionsHandler = /** @class */ (function () {\r\n    function ActionsHandler() {\r\n        this.duplicateEventsArray = ['keydown', 'keypress', 'input', 'keyup'];\r\n    }\r\n    ActionsHandler.prototype.resolveEventName = function (eventName) {\r\n        if (eventName === 'keyup') {\r\n            return 'input';\r\n        }\r\n        else {\r\n            return eventName;\r\n        }\r\n    };\r\n    ActionsHandler.prototype.areEventsDuplicates = function (eventName1, eventName2) {\r\n        return (this.duplicateEventsArray.includes(eventName1) &&\r\n            this.duplicateEventsArray.includes(eventName2));\r\n    };\r\n    ActionsHandler.prototype.handle = function (actions) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, Promise.resolve()\r\n                        .then(function () { return _this.batchInputActions(actions); })\r\n                        .then(function (actions) {\r\n                        Console_1.default.log('batchInputActions: ', actions);\r\n                        return _this.batchFocusAndClickActions(actions);\r\n                    })\r\n                        .then(function (actions) {\r\n                        Console_1.default.log('batchFocusAndClickActions: ', actions);\r\n                        return _this.filterLastActionIfNeeded(actions);\r\n                    })\r\n                        .then(function (actions) {\r\n                        Console_1.default.log('filterLastActionIfNeeded: ', actions);\r\n                        return _this.batchActionsForSelect(actions);\r\n                    })\r\n                        .then(function (actions) {\r\n                        Console_1.default.log('batchActionsForSelect: ', actions);\r\n                        return _this.splitActionsOnChunks(actions);\r\n                    })\r\n                        .then(function (chunks) {\r\n                        Console_1.default.log('chunks: ', chunks);\r\n                        return chunks;\r\n                    })];\r\n            });\r\n        });\r\n    };\r\n    ActionsHandler.prototype.batchInputActions = function (actions) {\r\n        var _this = this;\r\n        var res = [];\r\n        actions.forEach(function (action) {\r\n            var indexOfLastInteraction = res.map(helper_1.isUserInteractionAction).lastIndexOf(true);\r\n            if (indexOfLastInteraction === -1) {\r\n                res.push(action);\r\n                return;\r\n            }\r\n            var indexOfLastRequest = res.map(helper_1.isRequestAction).lastIndexOf(true);\r\n            if (helper_1.isUserInteractionAction(action)) {\r\n                var lastPushedInteraction = res[indexOfLastInteraction];\r\n                // if last request raised by input was done later than last interaction and\r\n                // current event is keydown(so user again entered value)\r\n                // we don't need to merge current interaction with some of previous ones,\r\n                // we just push it to destination array\r\n                if (indexOfLastRequest > indexOfLastInteraction &&\r\n                    action.eventName === 'keydown' &&\r\n                    lastPushedInteraction.eventName === 'input') {\r\n                    res.push(action);\r\n                    return;\r\n                }\r\n                if (action.dataHook === lastPushedInteraction.dataHook &&\r\n                    // we skip select element there for tests,\r\n                    // because when page.select() is called in puppeteer, only input event is collected,\r\n                    // we should avoid batching of them.\r\n                    // For real case(when user manually selects value) it isn't needed, because when selecting\r\n                    // value manually 3 events are collected: 'click', 'input', 'click'\r\n                    action.tagName !== 'SELECT' &&\r\n                    _this.areEventsDuplicates(action.eventName, lastPushedInteraction.eventName)) {\r\n                    lastPushedInteraction.value = action.value;\r\n                    if (action.eventName === 'input') {\r\n                        // inputData is needed for 'input' which caused async requests,\r\n                        // in this case we should use only last entered symbol, but not full value;\r\n                        // because of this field is undefined for 'keyup' event which is triggered after 'input',\r\n                        // we make sure that this field isn't cleared by undefined from 'keyup' action.\r\n                        lastPushedInteraction.inputData = action.inputData;\r\n                    }\r\n                    lastPushedInteraction.eventName = _this.resolveEventName(action.eventName);\r\n                    return;\r\n                }\r\n                // for checkbox and radio inputs\r\n                if (action.dataHook === lastPushedInteraction.dataHook &&\r\n                    action.eventName === 'input' &&\r\n                    lastPushedInteraction.eventName === 'click' &&\r\n                    (action.inputType === 'checkbox' || action.inputType === 'radio')) {\r\n                    lastPushedInteraction.value = action.value;\r\n                    lastPushedInteraction.eventName = 'click';\r\n                    return;\r\n                }\r\n            }\r\n            else if (helper_1.isDomMutationAction(action)) {\r\n                var indexToGetLastMutations = indexOfLastInteraction > indexOfLastRequest ? indexOfLastInteraction : indexOfLastRequest;\r\n                var lastPushedMutations = res.slice(indexToGetLastMutations).filter(helper_1.isDomMutationAction);\r\n                var similarMutation = lastPushedMutations.find(function (mutation) {\r\n                    return action.dataHook === mutation.dataHook &&\r\n                        helper_1.bothTypesAreAttributeOrNot(action.type, mutation.type) &&\r\n                        action.attributeName === mutation.attributeName &&\r\n                        action.raisedByRequest === mutation.raisedByRequest;\r\n                });\r\n                if (similarMutation) {\r\n                    similarMutation.value = action.value;\r\n                    similarMutation.type = action.type;\r\n                    similarMutation.HTML = action.HTML;\r\n                    return;\r\n                }\r\n            }\r\n            res.push(action);\r\n        });\r\n        return res;\r\n    };\r\n    ActionsHandler.prototype.batchFocusAndClickActions = function (actions) {\r\n        var res = [];\r\n        actions.forEach(function (action) {\r\n            var indexOfLastInteraction = res.map(helper_1.isUserInteractionAction).lastIndexOf(true);\r\n            if (indexOfLastInteraction === -1) {\r\n                res.push(action);\r\n                return;\r\n            }\r\n            if (helper_1.isUserInteractionAction(action)) {\r\n                var lastPushedInteraction = res[indexOfLastInteraction];\r\n                if (action.dataHook === lastPushedInteraction.dataHook &&\r\n                    ((action.eventName === 'focus' && lastPushedInteraction.eventName === 'mousedown') ||\r\n                        (action.eventName === 'mouseup' && lastPushedInteraction.eventName === 'focus') ||\r\n                        (action.eventName === 'click' && lastPushedInteraction.eventName === 'mouseup') ||\r\n                        // this is for button if it was previously clicked\r\n                        (action.eventName === 'mouseup' && lastPushedInteraction.eventName === 'mousedown'))) {\r\n                    res.splice(indexOfLastInteraction, 1, action);\r\n                    return;\r\n                }\r\n                // if there are two click actions recorded from one event handler but for two elements(bubbling)\r\n                // we just skip second one\r\n                if (action.dataHook === lastPushedInteraction.dataHook &&\r\n                    action.currentTargetDataHook !== lastPushedInteraction.currentTargetDataHook &&\r\n                    ((action.eventName === 'click' && lastPushedInteraction.eventName === 'click') ||\r\n                        (action.eventName === 'mousedown' && lastPushedInteraction.eventName === 'mousedown') ||\r\n                        (action.eventName === 'mouseup' && lastPushedInteraction.eventName === 'mouseup'))) {\r\n                    return;\r\n                }\r\n                // if user focuses or clicks on some element, previous blur is redundant\r\n                if ((action.eventName === 'focus' || action.eventName === 'click') &&\r\n                    lastPushedInteraction.eventName === 'blur') {\r\n                    // there we also check if there is mousedown event before blur,\r\n                    // we just delete it if it exists\r\n                    // POSSIBLE_BUG: it can cause BUG with mutations for mousedown event\r\n                    var indexOfLastButOneInteraction = res\r\n                        .slice(0, indexOfLastInteraction)\r\n                        .map(helper_1.isUserInteractionAction)\r\n                        .lastIndexOf(true);\r\n                    if (indexOfLastButOneInteraction !== -1) {\r\n                        var lastButOnePushedInteraction = res[indexOfLastButOneInteraction];\r\n                        if (lastButOnePushedInteraction.eventName === 'mousedown' &&\r\n                            lastButOnePushedInteraction.dataHook === action.dataHook) {\r\n                            res.splice(indexOfLastInteraction, 1, action);\r\n                            res.splice(indexOfLastButOneInteraction, 1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        res.splice(indexOfLastInteraction, 1, action);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            res.push(action);\r\n        });\r\n        return res;\r\n    };\r\n    /**\r\n     * This method batch actions only for <select> element\r\n     * @param actionChunks\r\n     */\r\n    ActionsHandler.prototype.batchActionsForSelect = function (actions) {\r\n        var res = [];\r\n        actions.forEach(function (action) {\r\n            var indexOfLastInteraction = res.map(helper_1.isUserInteractionAction).lastIndexOf(true);\r\n            if (indexOfLastInteraction === -1) {\r\n                res.push(action);\r\n                return;\r\n            }\r\n            var indexOfLastButOneInteraction = res\r\n                .slice(0, indexOfLastInteraction)\r\n                .map(helper_1.isUserInteractionAction)\r\n                .lastIndexOf(true);\r\n            if (indexOfLastButOneInteraction === -1) {\r\n                res.push(action);\r\n                return;\r\n            }\r\n            if (helper_1.isUserInteractionAction(action)) {\r\n                var lastPushedInteraction = res[indexOfLastInteraction];\r\n                var lastButOnePushedInteraction = res[indexOfLastButOneInteraction];\r\n                if (action.tagName === 'SELECT' &&\r\n                    action.dataHook === lastPushedInteraction.dataHook &&\r\n                    action.dataHook === lastButOnePushedInteraction.dataHook &&\r\n                    action.eventName === 'click' &&\r\n                    lastPushedInteraction.eventName === 'input' &&\r\n                    lastButOnePushedInteraction.eventName === 'click') {\r\n                    res.splice(indexOfLastInteraction, 1);\r\n                    lastButOnePushedInteraction.value = action.value;\r\n                    // set 'input' because 'input' is triggered when item is selected\r\n                    // with page.select(), so our tests and real cases are consistent\r\n                    lastButOnePushedInteraction.eventName = 'input';\r\n                    return;\r\n                }\r\n            }\r\n            res.push(action);\r\n        });\r\n        return res;\r\n    };\r\n    ActionsHandler.prototype.filterLastActionIfNeeded = function (actions) {\r\n        var lastAction = actions[actions.length - 1];\r\n        if (helper_1.isUserInteractionAction(lastAction) && lastAction.eventName === 'blur') {\r\n            // delete last action, if it is 'blur' UserInteractionAction,\r\n            // because this event was caused by pressing Finish button\r\n            return actions.slice(0, actions.length - 1);\r\n        }\r\n        return actions;\r\n    };\r\n    ActionsHandler.prototype.splitActionsOnChunks = function (actions) {\r\n        return actions.reduce(function (acc, currVal, currIndex) {\r\n            if (helper_1.isUserInteractionAction(currVal) || (helper_1.isRequestAction(currVal) && currIndex === 0)) {\r\n                acc.push([currVal]);\r\n            }\r\n            else {\r\n                acc[acc.length - 1].push(currVal);\r\n            }\r\n            return acc;\r\n        }, []);\r\n    };\r\n    return ActionsHandler;\r\n}());\r\nexports.default = ActionsHandler;\r\n\n\n//# sourceURL=webpack:///./src/client/ActionsHandler.ts?");

/***/ }),

/***/ "./src/client/Collector.ts":
/*!*********************************!*\
  !*** ./src/client/Collector.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Console_1 = __webpack_require__(/*! ../Console */ \"./src/Console.ts\");\r\nvar Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/client/Constants.ts\");\r\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./src/client/helper.ts\");\r\n/*\r\n\r\n  There are four types of data that are collected:\r\n  1. Initial outer HTML of elements\r\n  2. User interactions(are collected via addEventListener):\r\n    - 'click'\r\n    - 'input',\r\n    - ...\r\n  3. DOM changes(result of user interaction and/or request to backend) - are collected via MutationObserver:\r\n    - attributes\r\n      a) value\r\n      b) disabled\r\n      c) className\r\n        ...\r\n    - characterData (text) - in this case we find nearest parent with data-hook\r\n    - childList - is useful in cases when CharacterData node or HTMLElement was added to page, or deleted from it\r\n  4. Requests sent with window.fetch: url, method, body(body isn't recorded yet)\r\n  NOT SOLVED PROBLEMS:\r\n  1) If input[type=\"checkbox\"] or input[type=\"radio\"] is clicked =>\r\n      it becomes checked, but this change will not be collected, because HTML isn't changed.\r\n  2) If value in <select> is selected => DOM also isn't changed\r\n*/\r\nvar Collector = /** @class */ (function () {\r\n    function Collector(_a) {\r\n        var indicatorQuerySelector = _a.indicatorQuerySelector, errorsArray = _a.errorsArray;\r\n        var _this = this;\r\n        this.actions = [];\r\n        this.initialMarkup = [];\r\n        this.eventListenersCallbacksMap = [];\r\n        this.requestStatus = 'none';\r\n        this.requestStatusOfMutation = 'none';\r\n        this.interactionElementTagNames = ['input', 'textarea', 'button', 'select'];\r\n        this.eventListenersCallbacksMap = [\r\n            'click',\r\n            'input',\r\n            'keyup',\r\n            'keydown',\r\n            'keypress',\r\n            'focus',\r\n            'blur',\r\n            'mousedown',\r\n            'mouseup'\r\n        ].map(function (eventName) {\r\n            return {\r\n                eventName: eventName,\r\n                callback: function (e) { return _this.eventListener(e, eventName); }\r\n            };\r\n        });\r\n        this.indicator = null;\r\n        this.indicatorQuerySelector = indicatorQuerySelector;\r\n        this.errorsArray = errorsArray;\r\n    }\r\n    Collector.prototype.start = function () {\r\n        var _this = this;\r\n        this.url = window.location.href;\r\n        this.collectFetchRequests();\r\n        this.handleUrlChange();\r\n        window.addEventListener('DOMContentLoaded', function () {\r\n            _this.checkElementsDataHookOnUniqueness();\r\n            _this.initializeIndicator();\r\n            _this.getInitialMarkup();\r\n            _this.registerEventListeners();\r\n            _this.registerMutationObservers();\r\n        });\r\n    };\r\n    Collector.prototype.checkElementsDataHookOnUniqueness = function () {\r\n        var allDataHooks = Array.from(document.querySelectorAll('[data-hook]'));\r\n        var dataHookCountMap = allDataHooks\r\n            .map(function (el) { return el.getAttribute('data-hook'); })\r\n            .reduce(function (acc, currVal) {\r\n            var _a;\r\n            return Object.assign(acc, (_a = {}, _a[currVal] = (acc[currVal] || 0) + 1, _a));\r\n        }, {});\r\n        var duplicates = Object.keys(dataHookCountMap).filter(function (a) { return dataHookCountMap[a] > 1; });\r\n        if (duplicates.length > 0) {\r\n            this.errorsArray.push(\"\\n        Warning:\\n        There are duplicated data-hook attributes:<br/>\\n        \" + duplicates + \"<br/>\\n        Library doesn't work properly with duplicated data-hook attributes.\\n        Please make them all unique.\\n      \");\r\n        }\r\n    };\r\n    Collector.prototype.initializeIndicator = function () {\r\n        if (!this.indicatorQuerySelector) {\r\n            return;\r\n        }\r\n        var element = document.querySelector(this.indicatorQuerySelector);\r\n        if (!element) {\r\n            /* eslint-disable no-console */\r\n            console.error(\"indicatorQuerySelector is invalid, element isn't found\");\r\n            /* eslint-enable no-console */\r\n            return;\r\n        }\r\n        if (!(element instanceof HTMLElement)) {\r\n            /* eslint-disable no-console */\r\n            console.error(\"element selected for indicatorQuerySelector is not HTMLElement\");\r\n            /* eslint-enable no-console */\r\n            return;\r\n        }\r\n        this.indicator = element;\r\n    };\r\n    Collector.prototype.getInitialMarkup = function () {\r\n        var _this = this;\r\n        Array.from(document.querySelectorAll('[data-hook]')).forEach(function (element) {\r\n            _this.initialMarkup.push({\r\n                dataHook: element.getAttribute('data-hook'),\r\n                outerHTML: element.outerHTML\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     *\r\n     * Registering Event listeners to collect User interactions\r\n     *\r\n     */\r\n    Collector.prototype.registerEventListeners = function () {\r\n        var _this = this;\r\n        var elements = document.querySelectorAll('[data-hook]');\r\n        [].forEach.call(elements, function (el) { return _this.registerEventListenersForElement(el); });\r\n    };\r\n    Collector.prototype.registerEventListenersForElement = function (el) {\r\n        var eventNames = this.eventListenersCallbacksMap.map(function (item) { return item.eventName; });\r\n        this.eventListenersCallbacksMap.forEach(function (_a) {\r\n            var callback = _a.callback, eventName = _a.eventName;\r\n            el.addEventListener(eventName, callback);\r\n        });\r\n        Console_1.default.log(\"Registered \" + eventNames + \" event listeners on: \", el);\r\n    };\r\n    Collector.prototype.unregisterEventListeners = function () {\r\n        var _this = this;\r\n        var elements = document.querySelectorAll('[data-hook]');\r\n        var eventNames = this.eventListenersCallbacksMap.map(function (item) { return item.eventName; });\r\n        [].forEach.call(elements, function (el) {\r\n            _this.eventListenersCallbacksMap.forEach(function (_a) {\r\n                var callback = _a.callback, eventName = _a.eventName;\r\n                el.removeEventListener(eventName, callback);\r\n            });\r\n            Console_1.default.log(\"Unregistered \" + eventNames + \" event listeners on: \", el);\r\n        });\r\n    };\r\n    // TODO: wrong using can be detected exactly!!!\r\n    // using mousedown\r\n    Collector.prototype.handleFastInputAfterClick = function (e, eventName) {\r\n        if (eventName === 'click' &&\r\n            (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement)) {\r\n            var clickIsTriggeredAfterInputEvent = this.actions\r\n                .filter(helper_1.isUserInteractionAction)\r\n                .slice(-2)\r\n                .some(function (action) {\r\n                return ['keydown', 'keyup', 'input', 'keypress'].some(function (item) { return item === action.eventName; });\r\n            });\r\n            if (clickIsTriggeredAfterInputEvent) {\r\n                this.errorsArray.push(\"Warning: \\n         \\n          Did you intentionally type value in input(or textarea) element, and then clicked on it?<br/>\\n          If no, it seems that you clicked on your input and started to enter symbols at once, library\\n          doesn't handle this case properly now, after click on input/textarea elements, please \\n          wait 1 second before input.<br/><br/>\\n          Now it is better to reload page and start from scratch.\");\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * TODO: ADD TESTS!!!!!\r\n     * It is prohibited to interact with page till all async requests are finished,\r\n     * i.e. user clicked button that caused async request, request isn't finished yet but user clicked some element.\r\n     * This case isn't handled by library in right way.\r\n     * But even if this case would be implemented in right way, it is useless until mocking of requests is implemented,\r\n     * because time of responses to async requests differ from test run to test run.\r\n     *\r\n     * This method finds out if programmer interacts with page till all async requests are finished,\r\n     * if it is such case, error message is pushed to errorsArray\r\n     */\r\n    Collector.prototype.handleInteractionTillRequestsAreFinished = function (e, eventName) {\r\n        if (!this.allRequestsAreFinished()) {\r\n            var indexOfLastRequest = this.actions.map(helper_1.isRequestAction).lastIndexOf(true);\r\n            var indexOfInteractionCausedRequest = this.actions\r\n                .slice(0, indexOfLastRequest)\r\n                .map(helper_1.isUserInteractionAction)\r\n                .lastIndexOf(true);\r\n            var interaction = this.actions[indexOfInteractionCausedRequest];\r\n            var errorShouldBeShown = false;\r\n            switch (interaction.eventName) {\r\n                case 'click': {\r\n                    if (eventName !== 'blur') {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'input': {\r\n                    if (eventName !== 'keyup') {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'keyup': {\r\n                    errorShouldBeShown = true;\r\n                    break;\r\n                }\r\n                case 'keydown': {\r\n                    if (!['keypress', 'input', 'keyup'].some(function (item) { return item === eventName; })) {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'keypress': {\r\n                    if (!['input', 'keyup'].some(function (item) { return item === eventName; })) {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'focus': {\r\n                    // 'click' is needed there??\r\n                    if (!['mouseup', 'click'].some(function (item) { return item === eventName; })) {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'blur': {\r\n                    if (!['focus', 'mouseup', 'click'].some(function (item) { return item === eventName; })) {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'mousedown': {\r\n                    if (!['blur', 'focus', 'mouseup', 'click'].some(function (item) { return item === eventName; })) {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'mouseup': {\r\n                    if (eventName !== 'click') {\r\n                        errorShouldBeShown = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (errorShouldBeShown) {\r\n                this.errorsArray.push(\"\\n          Warning: you interacted with page until all async requests are finished.\\n          More likely generated code will be wrong.<br/>\\n          Indicator line below shows when all async requests are finished.<br/>\\n          If it is red please don't interact with page.<br/><br/>\\n          Now it is better to reload page and start from scratch.\\n        \");\r\n            }\r\n        }\r\n    };\r\n    Collector.prototype.handleUrlChange = function () {\r\n        var _this = this;\r\n        this.handleUrlTimerId = window.setInterval(function () {\r\n            if (window.location.href !== _this.url) {\r\n                _this.errorsArray.push(\"\\n          Warning:\\n          \\n          Detected window.location.href change, route transitions aren't supported by library yet.\\n          Please open url you want to test, reload page on this url and start whole process from scratch. \\n        \");\r\n                window.clearInterval(_this.handleUrlTimerId);\r\n            }\r\n        }, 100);\r\n    };\r\n    Collector.prototype.eventListener = function (e, eventName) {\r\n        if (this.requestStatus === 'ended') {\r\n            Console_1.default.log(\"Set request status to 'none'\");\r\n            this.requestStatus = 'none';\r\n        }\r\n        Console_1.default.group(eventName + \" event handler callback is called\");\r\n        if (!(e.target instanceof HTMLElement) || !e.target.hasAttribute('data-hook')) {\r\n            Console_1.default.log(\"Skipping \" + eventName + \" for \", e.target, \" because it isn't HTMLElement or doesn't have data-hook attribute\");\r\n            Console_1.default.groupEnd();\r\n            return;\r\n        }\r\n        if (eventName === 'input' &&\r\n            e.target instanceof HTMLInputElement &&\r\n            e.target.type === 'number') {\r\n            // hack for input[type=\"number\"]: DOM of this input changes only when other element is focused\r\n            // so we should manually trigger change of DOM to trigger invocation of MutationObserver callback\r\n            e.target.setAttribute('value', e.target.value);\r\n        }\r\n        if (e.target instanceof HTMLButtonElement && eventName === 'blur') {\r\n            // blur event is triggered on button even when DOM changes!!!\r\n            Console_1.default.log(\"Skipping 'blur' event for button\");\r\n            Console_1.default.groupEnd();\r\n            return;\r\n        }\r\n        this.handleFastInputAfterClick(e, eventName);\r\n        this.handleInteractionTillRequestsAreFinished(e, eventName);\r\n        var interaction = {\r\n            dataHook: e.target.getAttribute('data-hook'),\r\n            eventName: eventName,\r\n            // @ts-ignore\r\n            value: e.target.value || '',\r\n            // @ts-ignore\r\n            inputData: e.data,\r\n            tagName: e.target.tagName,\r\n            currentTargetDataHook: e.currentTarget && e.currentTarget instanceof HTMLElement\r\n                ? e.currentTarget.getAttribute('data-hook')\r\n                : undefined\r\n        };\r\n        if (interaction.tagName === 'INPUT') {\r\n            interaction.inputType = e.target.getAttribute('type');\r\n        }\r\n        this.actions.push(interaction);\r\n        Console_1.default.log(\"Collected '\" + eventName + \"' event for: \\n\", e.target);\r\n        Console_1.default.groupEnd();\r\n        return;\r\n    };\r\n    /**\r\n     * Registering MutationObserver to collect DOM mutations\r\n     */\r\n    Collector.prototype.registerMutationObservers = function () {\r\n        var _this = this;\r\n        this.mutationObserver = new MutationObserver(function (mutationRecords) {\r\n            if (mutationRecords.every(function (record) { return record.target === _this.indicator; })) {\r\n                return;\r\n            }\r\n            // use setTimeout because we need to push mutation after actual action that caused this mutation\r\n            // it is needed for such cases:\r\n            // 1) Programmer added several input event listeners to element\r\n            // 2) We added one more to record input event\r\n            // 3) When creating test programmer inputs value in field, first event listener is executed,\r\n            //    as a result mutation happens and is pushed to actions array,\r\n            //    but our event listener isn't pushed yet to actions array! - it is wrong\r\n            _this.requestStatusOfMutation = _this.requestStatus;\r\n            setTimeout(function () {\r\n                Console_1.default.group('MutationObserver callback is called');\r\n                Console_1.default.log('Mutation batch:', mutationRecords);\r\n                var handledMutationRecords = _this.deleteSimilarMutationsRecords(mutationRecords);\r\n                handledMutationRecords.forEach(function (record) {\r\n                    switch (record.type) {\r\n                        case 'childList': {\r\n                            _this.handleChildListMutationRecord(record);\r\n                            break;\r\n                        }\r\n                        case 'characterData': {\r\n                            _this.handleCharacterDataMutationRecord(record);\r\n                            break;\r\n                        }\r\n                        case 'attributes': {\r\n                            _this.handleElement({\r\n                                element: record.target,\r\n                                type: 'attributes',\r\n                                attributeName: record.attributeName,\r\n                                oldValue: record.oldValue,\r\n                                // @ts-ignore\r\n                                value: record.target.getAttribute(record.attributeName)\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                Console_1.default.groupEnd();\r\n            }, 0);\r\n        });\r\n        this.mutationObserver.observe(document, {\r\n            childList: true,\r\n            attributes: true,\r\n            characterData: true,\r\n            subtree: true,\r\n            attributeOldValue: true,\r\n            characterDataOldValue: true\r\n        });\r\n    };\r\n    // There are cases when mutation batch contains similar mutation records.\r\n    // Similar means: they have the same target, type and attributeName.\r\n    // For now such records were detected only when using textarea\r\n    Collector.prototype.deleteSimilarMutationsRecords = function (mutationRecords) {\r\n        var handledMutationRecords = [];\r\n        mutationRecords.forEach(function (record) {\r\n            var similarBatchedRecord = handledMutationRecords.find(function (batchedRecord) {\r\n                return record.target === batchedRecord.target &&\r\n                    record.type === batchedRecord.type &&\r\n                    record.attributeName === batchedRecord.attributeName;\r\n            });\r\n            if (typeof similarBatchedRecord !== 'undefined') {\r\n                var addedRecordNode = Array.from(record.addedNodes)[0];\r\n                var removedBatchedRecordNode = Array.from(similarBatchedRecord.removedNodes)[0];\r\n                // if the same text node was removed and then added\r\n                // we delete already pushed mutation record from batched records and skip current one\r\n                if (addedRecordNode instanceof Text &&\r\n                    removedBatchedRecordNode instanceof Text &&\r\n                    addedRecordNode.data === removedBatchedRecordNode.data) {\r\n                    var index = handledMutationRecords.findIndex(function (el) { return el === similarBatchedRecord; });\r\n                    handledMutationRecords.splice(index, 1);\r\n                    Console_1.default.log('Skipping two mutation records: first for adding Text Node, second for deleting TextNode - they are mutually exclusive');\r\n                    return;\r\n                }\r\n                else {\r\n                    handledMutationRecords.push(record);\r\n                }\r\n            }\r\n            else {\r\n                handledMutationRecords.push(record);\r\n            }\r\n        });\r\n        return handledMutationRecords;\r\n    };\r\n    Collector.prototype.handleChildListMutationRecord = function (record) {\r\n        var addedNodes = Array.from(record.addedNodes);\r\n        if (addedNodes.length == 0 &&\r\n            Array.from(record.removedNodes).every(function (node) { return node instanceof Text && node.data === ''; })) {\r\n            Console_1.default.log('Skipping recording mutation for removed Text Node, because its value was empty string');\r\n            return;\r\n        }\r\n        if (addedNodes.length > 0 &&\r\n            addedNodes.every(function (node) { return node instanceof Text && node.data === ''; })) {\r\n            Console_1.default.log('Skipping recording mutation for added Text Nodes, because their values are empty strings');\r\n            return;\r\n        }\r\n        var numberOfHandledAddedChildren = this.tryToHandleChildrenNodes('childList-added-node', record.addedNodes);\r\n        this.checkDataHookOnUniquenessAndRegisterEventListenersOnAddedNodes(record.addedNodes);\r\n        var numberOfHandledRemovedChildren = this.tryToHandleChildrenNodes('childList-removed-node', record.removedNodes);\r\n        // we handle original target of childList mutation\r\n        // only if no added and removed nodes were handled(it is possible\r\n        // if record.target don't have children Element Nodes with [data-hook] attribute)\r\n        //\r\n        // in this case content of original target node changed, but it is not added to the DOM\r\n        // so innerHTML should be checked\r\n        if (numberOfHandledAddedChildren === 0 && numberOfHandledRemovedChildren === 0) {\r\n            // record.target can be only Element Node(because type of current mutation is childList)\r\n            // not we handle only HTMLElement but not SVGElement or other types\r\n            this.handleElement({\r\n                element: record.target,\r\n                type: 'childList',\r\n                htmlType: 'inner'\r\n            });\r\n        }\r\n    };\r\n    Collector.prototype.handleCharacterDataMutationRecord = function (record) {\r\n        var parentElement = record.target.parentElement;\r\n        // This case is possible if we have such piece of code:\r\n        // <div data-hook=\"div\">\r\n        //   [input value]\r\n        //   <input data-hook=\"input\" />\r\n        // </div>\r\n        // And user enters value in input\r\n        if (this.elementHasInteractionElementsAsChildren(parentElement)) {\r\n            Console_1.default.log(\"Skipping recording mutation for Text Node, because parent of this Text Node has child with tagName equal to one of: INPUT, BUTTON, TEXTAREA, SELECT\");\r\n            return;\r\n        }\r\n        // // if content of interaction element changed\r\n        // //  For example:\r\n        // // <button data-hook=\"attr\">\r\n        // //   {buttonTextThatChanges}\r\n        // // </button>\r\n        // // TODO: in this case we should handle innerHTML of button. Checking of outerHTML is redundant\r\n        // if (this.interactionElementTagNames.some(tagName => tagName === parentElement.tagName)) {\r\n        // }\r\n        // TODO: in case if contentEditable Element is changed:\r\n        // - it doesn't handle inserted value properly\r\n        // - divs and spans can be inserted into DOM which will wrap entered text,\r\n        // these divs and spans don't have [data-hook] attribute, so mutation will be skipped.\r\n        // But it should be skipped only if\r\n        //  contentEditable Element doesn't have [data-hook] atttribute itself\r\n        this.handleElement({ element: parentElement, type: 'characterData', htmlType: 'inner' });\r\n    };\r\n    Collector.prototype.elementHasInteractionElementsAsChildren = function (element) {\r\n        return (Array.from(element.querySelectorAll(this.interactionElementTagNames.join(','))).length > 0);\r\n    };\r\n    /**\r\n     * Try to handle(i.e add to mutationsArray) nodes passed in NodeList,\r\n     * returns number of successfully handled Nodes.\r\n     *\r\n     * Node won't successfully handled if all next conditions are true:\r\n     * 1) it isn't HTMLElement\r\n     * 2) it doesn't have [data-hook] attribute\r\n     * 3) it doesn't have at least one HTMLElement child with data-hook attribute\r\n     */\r\n    Collector.prototype.tryToHandleChildrenNodes = function (type, nodeList) {\r\n        var _this = this;\r\n        return Array.from(nodeList)\r\n            .map(function (element) {\r\n            if (element instanceof HTMLElement) {\r\n                var childrenWithDataHookAttribute = _this.getMostNestedChildrenWithDataHookAttribute(element);\r\n                if (childrenWithDataHookAttribute.length > 0) {\r\n                    Console_1.default.log(\"Next element has children with data-hook attribute, so \" + type + \" mutation\\n            will be handled for its children: \", element);\r\n                    var handledChildrenNumber_1 = 0;\r\n                    childrenWithDataHookAttribute.forEach(function (child) {\r\n                        var handled = _this.handleElement({ element: child, type: type });\r\n                        if (handled) {\r\n                            handledChildrenNumber_1++;\r\n                        }\r\n                    });\r\n                    return handledChildrenNumber_1;\r\n                }\r\n                else {\r\n                    Console_1.default.log(\"Next element has no children with data-hook attribute, so \" + type + \" mutation\\n            will be handled for this element itself: \", element);\r\n                    return _this.handleElement({ element: element, type: type });\r\n                }\r\n            }\r\n            return false;\r\n        })\r\n            .filter(Boolean).length;\r\n    };\r\n    /**\r\n     * Recursively gets children with data-hook attribute for all most nested sub-trees.\r\n     * Example:\r\n     * <div data-hook=\"root-div\">\r\n     *  <span data-hook=\"span1\">Some text</span>\r\n     *  <div data-hook=\"div1\">\r\n     *    <div data-hook=\"div1-nested\">\r\n     *      <span data-hook=\"span2\">Some text2</span>\r\n     *    </div>\r\n     *  </div>\r\n     *  <div data-hook=\"div2\">\r\n     *    <input data-hook=\"input\" value=\"val\" />\r\n     *  </div>\r\n     * </div>\r\n     *\r\n     * In this case elements with next data-hooks will be returned in array:\r\n     * [\"span1\", \"span2\", \"input\"]\r\n     */\r\n    Collector.prototype.getMostNestedChildrenWithDataHookAttribute = function (element) {\r\n        var _this = this;\r\n        return Array.from(element.children)\r\n            .map(function (element) {\r\n            if (!(element instanceof HTMLElement)) {\r\n                return [];\r\n            }\r\n            var childrenWithDataHookAttribute = _this.getMostNestedChildrenWithDataHookAttribute(element);\r\n            if (childrenWithDataHookAttribute.length > 0) {\r\n                return childrenWithDataHookAttribute;\r\n            }\r\n            else {\r\n                if (element.hasAttribute('data-hook')) {\r\n                    return [element];\r\n                }\r\n            }\r\n            return [];\r\n        })\r\n            .reduce(function (acc, currVal) {\r\n            return acc.concat(currVal);\r\n        }, []);\r\n    };\r\n    /**\r\n     * Returns true if element was handled, false otherwise\r\n     */\r\n    Collector.prototype.handleElement = function (_a) {\r\n        var element = _a.element, type = _a.type, attributeName = _a.attributeName, oldValue = _a.oldValue, value = _a.value, _b = _a.htmlType, htmlType = _b === void 0 ? 'outer' : _b;\r\n        var dataHook = element.getAttribute('data-hook');\r\n        if (!dataHook) {\r\n            Console_1.default.log('Skipped mutation due lack of [data-hook] attribute: ', element);\r\n            return false;\r\n        }\r\n        var collectedMutation = {\r\n            type: type,\r\n            attributeName: attributeName,\r\n            oldValue: oldValue,\r\n            dataHook: dataHook,\r\n            HTML: htmlType === 'outer' ? element.outerHTML : element.innerHTML,\r\n            htmlType: htmlType,\r\n            value: value\r\n        };\r\n        // TODO: bug can be caused:\r\n        // first request.then(secondrequest)\r\n        // first request finished\r\n        // second request started\r\n        // mutation raised by first request is catched by MutationObserver\r\n        if (this.requestStatusOfMutation === 'ended') {\r\n            collectedMutation.raisedByRequest = true;\r\n        }\r\n        Console_1.default.log('Collected mutation: ', collectedMutation);\r\n        this.actions.push(collectedMutation);\r\n        return true;\r\n    };\r\n    Collector.prototype.checkDataHookOnUniquenessAndRegisterEventListenersOnAddedNodes = function (nodeList) {\r\n        var _this = this;\r\n        this.checkElementsDataHookOnUniqueness();\r\n        Array.from(nodeList).forEach(function (element) {\r\n            if (element instanceof HTMLElement) {\r\n                Array.from(element.querySelectorAll('[data-hook]')).forEach(function (el) {\r\n                    if (el instanceof HTMLElement) {\r\n                        _this.registerEventListenersForElement(el);\r\n                    }\r\n                });\r\n                if (element.hasAttribute('data-hook')) {\r\n                    _this.registerEventListenersForElement(element);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    Collector.prototype.finish = function () {\r\n        Console_1.default.group('Collector.finish');\r\n        this.unregisterEventListeners();\r\n        if (this.mutationObserver)\r\n            this.mutationObserver.disconnect();\r\n        // We assign actions and initialMarkup on window object for tests\r\n        // @ts-ignore\r\n        window.ACTIONS = this.actions;\r\n        // @ts-ignore\r\n        window.INITIAL_MARKUP = this.initialMarkup;\r\n        Console_1.default.log('Collected data: ', JSON.parse(JSON.stringify(this.actions)));\r\n        Console_1.default.log('Initial html of elements: ', JSON.parse(JSON.stringify(this.initialMarkup)));\r\n        Console_1.default.groupEnd();\r\n    };\r\n    Collector.prototype.allRequestsAreFinished = function () {\r\n        return this.actions.filter(helper_1.isRequestAction).every(function (req) { return !!req.finished; });\r\n    };\r\n    /**\r\n     * Collects information about all requests on page made with window.fetch\r\n     */\r\n    Collector.prototype.collectFetchRequests = function () {\r\n        var originalFetch = window.fetch;\r\n        var self = this;\r\n        var lastRequestId = 0;\r\n        window.fetch = function () {\r\n            var url = arguments[0];\r\n            if (url === Constants_1.SERVER_URL) {\r\n                return originalFetch.apply(this, arguments);\r\n            }\r\n            var method = arguments[1] ? arguments[1].method || 'get' : 'get';\r\n            var newId = ++lastRequestId;\r\n            var requestAction = {\r\n                id: newId,\r\n                url: url,\r\n                method: method,\r\n                responseStatus: 0,\r\n                finished: false\r\n            };\r\n            if (self.indicator) {\r\n                self.indicator.style.backgroundColor = 'red';\r\n            }\r\n            // we push 'pushing of RequestAction' to callback queue,\r\n            // it is needed to do easier handling of async actions in ActionsHandler\r\n            // Explanation: after user does some action which leads to request\r\n            // (clicks button or types value in input), bunch of actions are pushed to array:\r\n            // - keydown, keypress, input, keyup in case of typing in input,\r\n            // - focusin click in case of click\r\n            // setTimeout(() => {\r\n            Console_1.default.log(\"Pushed RequestAction to result array: \", requestAction);\r\n            self.actions.push(requestAction);\r\n            self.requestStatus = 'processing';\r\n            // }, 0);\r\n            return originalFetch.apply(this, arguments).then(function (response) {\r\n                // setTimeout(() => {\r\n                self.requestStatus = 'ended';\r\n                Console_1.default.log('Response has just arrived, set requestStatus to ended');\r\n                requestAction.responseStatus = response.status;\r\n                requestAction.finished = true;\r\n                // browser encodes url also, so we update url with encoded one\r\n                requestAction.url = response.url;\r\n                // if all requests are finished switch indicator to green\r\n                if (self.allRequestsAreFinished() && self.indicator) {\r\n                    self.indicator.style.backgroundColor = 'green';\r\n                }\r\n                // }, 0);\r\n                return response;\r\n            });\r\n        };\r\n    };\r\n    return Collector;\r\n}());\r\nexports.default = Collector;\r\n\n\n//# sourceURL=webpack:///./src/client/Collector.ts?");

/***/ }),

/***/ "./src/client/Constants.ts":
/*!*********************************!*\
  !*** ./src/client/Constants.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SERVER_URL = 'http://localhost:3000/writeFile';\r\n\n\n//# sourceURL=webpack:///./src/client/Constants.ts?");

/***/ }),

/***/ "./src/client/DataHandler.ts":
/*!***********************************!*\
  !*** ./src/client/DataHandler.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./src/client/helper.ts\");\r\nvar DataHandler = /** @class */ (function () {\r\n    function DataHandler() {\r\n    }\r\n    DataHandler.prototype.handleData = function (actions, initialMarkup) {\r\n        var _this = this;\r\n        var handledActions = [];\r\n        actions.forEach(function (action) {\r\n            if (helper_1.isDomMutationAction(action)) {\r\n                var initialAttrName = action.attributeName;\r\n                // @ts-ignore - boolean can't be assigned in collector, but it can be assigned there\r\n                // TODO: maybe it is needed to create separate type for handled data\r\n                var value = _this.handleAttributeValue(initialAttrName, action.value);\r\n                var attributeName = _this.handleAttributeName(action.attributeName);\r\n                // @ts-ignore - boolean can't be assigned in collector, but it can be assigned there\r\n                var oldValue = _this.handleAttributeValue(initialAttrName, action.oldValue);\r\n                handledActions.push(Object.assign({}, action, {\r\n                    value: value,\r\n                    attributeName: attributeName,\r\n                    oldValue: oldValue,\r\n                    /* eslint-disable quotes */\r\n                    HTML: action.HTML.replace(/'/g, \"\\\\'\")\r\n                    /* eslint-enable quotes */\r\n                }));\r\n            }\r\n            else if (helper_1.isRequestAction(action)) {\r\n                handledActions.push(Object.assign({}, action, {\r\n                    method: action.method.toUpperCase()\r\n                }));\r\n            }\r\n            else {\r\n                handledActions.push(Object.assign({}, action));\r\n            }\r\n        });\r\n        return {\r\n            handledActions: handledActions,\r\n            handledInitialMarkup: initialMarkup\r\n        };\r\n    };\r\n    DataHandler.prototype.handleAttributeName = function (attributeName) {\r\n        return attributeName === 'class' ? 'className' : attributeName;\r\n    };\r\n    // TODO: test should be added when all cases will be clear for this function\r\n    DataHandler.prototype.handleAttributeValue = function (attributeName, value) {\r\n        if (attributeName === 'disabled') {\r\n            return value === '';\r\n        }\r\n        else {\r\n            if (value === null)\r\n                return null;\r\n            return \"'\" + value + \"'\";\r\n        }\r\n    };\r\n    return DataHandler;\r\n}());\r\nexports.default = DataHandler;\r\n\n\n//# sourceURL=webpack:///./src/client/DataHandler.ts?");

/***/ }),

/***/ "./src/client/PuppeteerTestGenerator.ts":
/*!**********************************************!*\
  !*** ./src/client/PuppeteerTestGenerator.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Collector_1 = __webpack_require__(/*! ./Collector */ \"./src/client/Collector.ts\");\r\nvar DataHandler_1 = __webpack_require__(/*! ./DataHandler */ \"./src/client/DataHandler.ts\");\r\nvar ActionsHandler_1 = __webpack_require__(/*! ./ActionsHandler */ \"./src/client/ActionsHandler.ts\");\r\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./src/client/helper.ts\");\r\nvar Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/client/Constants.ts\");\r\nvar Console_1 = __webpack_require__(/*! ../Console */ \"./src/Console.ts\");\r\nvar PuppeteerTestGenerator = /** @class */ (function () {\r\n    function PuppeteerTestGenerator(_a) {\r\n        var _b = _a.addComments, addComments = _b === void 0 ? true : _b, indicatorQuerySelector = _a.indicatorQuerySelector, saveToFs = _a.saveToFs, errorsArray = _a.errorsArray, testName = _a.testName, testsFolder = _a.testsFolder;\r\n        this.duplicateEventsArray = ['keydown', 'keypress', 'input', 'keyup'];\r\n        this.collector = new Collector_1.default({\r\n            indicatorQuerySelector: indicatorQuerySelector,\r\n            errorsArray: errorsArray\r\n        });\r\n        this.saveToFs = saveToFs;\r\n        this.dataHandler = new DataHandler_1.default();\r\n        this.actionsHandler = new ActionsHandler_1.default();\r\n        this.addComments = addComments;\r\n        this.testName = testName;\r\n        this.testsFolder = testsFolder;\r\n    }\r\n    PuppeteerTestGenerator.prototype.start = function () {\r\n        this.collector.start();\r\n    };\r\n    PuppeteerTestGenerator.prototype.finish = function () {\r\n        var _this = this;\r\n        return this.transformDataAndGenerateCode().then(function (generatedCode) {\r\n            if (_this.saveToFs) {\r\n                return _this.saveFile(generatedCode);\r\n            }\r\n            else {\r\n                /* eslint-disable no-console */\r\n                console.log('saveToFs is false, so code is output to console: ');\r\n                console.log(generatedCode);\r\n                return;\r\n                /* eslint-enable no-console */\r\n            }\r\n        });\r\n    };\r\n    PuppeteerTestGenerator.prototype.saveFile = function (generatedCode) {\r\n        var url = this.collector.url;\r\n        return fetch(Constants_1.SERVER_URL, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                code: generatedCode,\r\n                testsFolder: this.testsFolder,\r\n                fileName: url.slice(url.lastIndexOf('/') + 1)\r\n            })\r\n        })\r\n            .then(function (res) {\r\n            if (res.status === 200) {\r\n                return new Promise(function (resolve) {\r\n                    resolve();\r\n                });\r\n            }\r\n            return Promise.reject(res);\r\n        })\r\n            .catch(function (error) {\r\n            /* eslint-disable no-console */\r\n            console.warn('Because of error occured when saving file, code is output to console: ');\r\n            console.log(generatedCode);\r\n            /* eslint-enable no-console */\r\n            return Promise.reject(error);\r\n        });\r\n    };\r\n    PuppeteerTestGenerator.prototype.transformDataAndGenerateCode = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, actions, initialMarkup, url, _b, handledActions, handledInitialMarkup, transformedActionChunks, generatedCode;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        this.collector.finish();\r\n                        _a = this.collector, actions = _a.actions, initialMarkup = _a.initialMarkup, url = _a.url;\r\n                        if (actions.length === 0) {\r\n                            throw new Error('Actions array is empty, test will be empty, please reload page and interact with elements on page');\r\n                        }\r\n                        _b = this.dataHandler.handleData(actions, initialMarkup), handledActions = _b.handledActions, handledInitialMarkup = _b.handledInitialMarkup;\r\n                        return [4 /*yield*/, this.actionsHandler.handle(handledActions)];\r\n                    case 1:\r\n                        transformedActionChunks = _c.sent();\r\n                        generatedCode = this.generateCode(transformedActionChunks, handledInitialMarkup, url);\r\n                        Console_1.default.log('Generated code: ', generatedCode);\r\n                        return [2 /*return*/, generatedCode];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCode = function (actionChunks, initMarkups, url) {\r\n        var firstChunk = actionChunks[0];\r\n        var gotoCode = '';\r\n        var testCaseCode = '';\r\n        // if on initial render of page some async requests are called\r\n        if (firstChunk.some(helper_1.isRequestAction) &&\r\n            firstChunk.filter(helper_1.isUserInteractionAction).length === 0) {\r\n            var requestActions = firstChunk.filter(helper_1.isRequestAction);\r\n            var initMarkupsThatChangedInFirstChunk_1 = this.getInitMarkupThatChanged(initMarkups, firstChunk.filter(helper_1.isDomMutationAction));\r\n            // TODO: check markup of elements when request is being sent on initial render\r\n            // let initialMarkupCode = '';\r\n            // initMarkupsThatChangedInFirstChunk.forEach(markup => {\r\n            //   initialMarkupCode += `\r\n            //     expect(\r\n            //       await page.$eval('[data-hook=\"${markup.dataHook}\"]', el => el.outerHTML)\r\n            //     ).toEqual(\r\n            //       '${markup.outerHTML}'\r\n            //     ),\r\n            //   `;\r\n            // });\r\n            // initialMarkupCode += '\\n';\r\n            gotoCode = this.generateCodeToWaitRequests(requestActions, \"await page.goto('\" + url + \"')\");\r\n            var initMarkupsWhichNotChecked = initMarkups.filter(function (markup) {\r\n                return typeof initMarkupsThatChangedInFirstChunk_1.find(function (firstChunkMarkup) { return firstChunkMarkup.dataHook === markup.dataHook; }) === 'undefined';\r\n            });\r\n            testCaseCode = this.generateTestCaseCode(actionChunks, initMarkupsWhichNotChecked);\r\n        }\r\n        else {\r\n            gotoCode = \"await page.goto('\" + url + \"');\";\r\n            testCaseCode = this.generateTestCaseCode(actionChunks, initMarkups);\r\n        }\r\n        // prettier-ignore\r\n        var code = \"\\n    const timeout = 30000;\\n\\n    describe(\\n      '\" + (this.testName ? this.testName : this.getTestName(url)) + \"',\\n      () => {\\n        let page;\\n        beforeAll(async () => {\\n          page = await global.browser.newPage();\\n          \" + gotoCode + \"\\n        }, timeout);\\n\\n        afterAll(async () => {\\n          await page.close();\\n        });\\n\\n        it(\\n          'first test',\\n           async () => {\\n            \" + testCaseCode + \"\\n           },\\n          timeout\\n        );\\n      }\\n    );\\n    \";\r\n        return code;\r\n    };\r\n    PuppeteerTestGenerator.prototype.getTestName = function (url) {\r\n        var pathname = url.slice(url.lastIndexOf('/') + 1);\r\n        return pathname[0].toUpperCase() + pathname.slice(1);\r\n    };\r\n    PuppeteerTestGenerator.prototype.getInitMarkupThatChanged = function (initMarkups, mutations) {\r\n        return initMarkups.filter(function (markup) {\r\n            return mutations.some(function (action) { return action.dataHook === markup.dataHook && action.type !== 'attributes'; });\r\n        });\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateTestCaseCode = function (actionChunks, initMarkups) {\r\n        var _this = this;\r\n        var allMutations = helper_1.getMutationsFromActionChunks(actionChunks);\r\n        var initMarkupsThatChanged = this.getInitMarkupThatChanged(initMarkups, allMutations);\r\n        var code = '';\r\n        // TODO: should check on start elements which were added to DOM later\r\n        // but it is not high priority\r\n        if (initMarkupsThatChanged.length > 0 && this.addComments) {\r\n            code += \"// check initial outerHTML of elements\";\r\n        }\r\n        // add initial markup expectations\r\n        initMarkupsThatChanged.forEach(function (markup) {\r\n            code += \"\\n        expect(\\n          await page.$eval('[data-hook=\\\"\" + markup.dataHook + \"\\\"]', el => el.outerHTML)\\n        ).toEqual(\\n          '\" + markup.outerHTML + \"'\\n        );\\n      \";\r\n        });\r\n        code += '\\n';\r\n        // Traverse action chunks and generate code\r\n        actionChunks.forEach(function (chunk, index) {\r\n            if (chunk.filter(helper_1.isRequestAction).length === 0) {\r\n                code += _this.generateCodeForSyncActionChunk(chunk, index, actionChunks, initMarkups);\r\n            }\r\n            else {\r\n                code += _this.generateCodeForAsyncActionChunk(chunk, index, actionChunks, initMarkups);\r\n            }\r\n        });\r\n        return code;\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCodeToWaitRequests = function (requestActions, causeOfRequestsCode) {\r\n        return \"\\n      \" + (this.addComments ? '\\n// trigger user action and wait for right request and response' : '') + \"\\n      await Promise.all([\\n      \" + requestActions\r\n            .map(function (requestAction) { return \"\\n        page.waitForRequest(\\n          request =>\\n            request.url() === '\" + requestAction.url + \"' &&\\n            request.method() === '\" + requestAction.method + \"'\\n        ),\\n        page.waitForResponse(\\n          response =>\\n            response.url() === '\" + requestAction.url + \"' &&\\n            response.status() === \" + requestAction.responseStatus + \"\\n        ),\\n      \"; })\r\n            .join('\\n') + \"\\n        \" + causeOfRequestsCode + \"\\n    ]);\\n    \";\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCodeForSimulatingUserAction = function (interaction, addSemicolon, causedAsyncRequest) {\r\n        if (addSemicolon === void 0) { addSemicolon = true; }\r\n        if (causedAsyncRequest === void 0) { causedAsyncRequest = false; }\r\n        var code = '';\r\n        switch (interaction.eventName) {\r\n            case 'input': {\r\n                if (interaction.tagName === 'SELECT') {\r\n                    code += \"await page.select('[data-hook=\\\"\" + interaction.dataHook + \"\\\"]', '\" + interaction.value + \"')\";\r\n                }\r\n                else {\r\n                    code += \"await page.type('[data-hook=\\\"\" + interaction.dataHook + \"\\\"]', '\" + (\r\n                    // for user typings which caused async requests use inputData, i.e last entered symbol\r\n                    causedAsyncRequest ? interaction.inputData : interaction.value) + \"')\";\r\n                }\r\n                break;\r\n            }\r\n            case 'click': {\r\n                code += \"await page.click('[data-hook=\\\"\" + interaction.dataHook + \"\\\"]')\";\r\n                break;\r\n            }\r\n            case 'focus': {\r\n                code += \"await page.focus('[data-hook=\\\"\" + interaction.dataHook + \"\\\"]')\";\r\n                break;\r\n            }\r\n            case 'blur': {\r\n                code += \"await page.evaluate(() => {\\n          document.querySelector('[data-hook=\\\"\" + interaction.dataHook + \"\\\"]').blur()\\n        })\";\r\n                break;\r\n            }\r\n            default:\r\n                throw new Error(\"Unsupported interaction type \" + interaction.eventName);\r\n        }\r\n        code += (addSemicolon ? ';' : '') + \"\\n\\n\";\r\n        return code;\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCodeForCheckingValuesAfterInteraction = function (mutations, initMarkups) {\r\n        var code = '';\r\n        mutations.forEach(function (mutation) {\r\n            if (mutation.type === 'attributes') {\r\n                code += \"expect(await page.$eval('[data-hook=\\\"\" + mutation.dataHook + \"\\\"]', el => el.\" + mutation.attributeName + \")).toEqual(\" + mutation.value + \");\";\r\n            }\r\n            else if (mutation.type === 'childList-removed-node') {\r\n                code += \"expect(\\n            await page.$('[data-hook=\\\"\" + mutation.dataHook + \"\\\"]')\\n          ).toEqual(null);\";\r\n            }\r\n            else {\r\n                code += \"expect(\\n            await page.$eval('[data-hook=\\\"\" + mutation.dataHook + \"\\\"]', el => el.\" + (mutation.htmlType === 'outer' ? 'outerHTML' : 'innerHTML') + \")\\n          ).toEqual(\\n            '\" + mutation.HTML + \"'\\n          );\";\r\n            }\r\n        });\r\n        code += '\\n';\r\n        return code;\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCodeToCheckMutationsBeforeInteraction = function (mutations, actionChunks, index) {\r\n        var previousMutations = helper_1.getMutationsFromActionChunks(actionChunks.slice(0, index));\r\n        var mutationsToBeChecked = mutations\r\n            .filter(function (mutation) { return mutation.type === 'attributes' && !mutation.raisedByRequest; })\r\n            .filter(function (mutation) {\r\n            // filter mutations which were already checked in one of the previous mutations\r\n            return !previousMutations.some(function (prevMutation) {\r\n                return prevMutation.dataHook === mutation.dataHook &&\r\n                    prevMutation.attributeName === mutation.attributeName;\r\n            });\r\n        });\r\n        var chunkInteraction = actionChunks[index].find(helper_1.isUserInteractionAction);\r\n        var code = '';\r\n        if (mutationsToBeChecked.length > 0 && this.addComments && chunkInteraction) {\r\n            code += \"\\n\\n// check attributes before '\" + chunkInteraction.eventName + \"' on '[data-hook=\\\"\" + chunkInteraction.dataHook + \"\\\"]' element\";\r\n        }\r\n        mutationsToBeChecked.forEach(function (mutation) {\r\n            if (mutation.type === 'attributes') {\r\n                code += \"\\n              expect(await page.$eval('[data-hook=\\\"\" + mutation.dataHook + \"\\\"]', el => el.\" + mutation.attributeName + \")).toEqual(\" + mutation.oldValue + \");\";\r\n            }\r\n        });\r\n        code += '\\n\\n';\r\n        return code;\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCodeForSyncActionChunk = function (chunk, index, actionChunks, initMarkups) {\r\n        var code = '';\r\n        var mutations = chunk.filter(helper_1.isDomMutationAction);\r\n        // generate code to check values before interaction(user action)\r\n        code += this.generateCodeToCheckMutationsBeforeInteraction(mutations, actionChunks, index);\r\n        var interaction = chunk.find(helper_1.isUserInteractionAction);\r\n        if (this.addComments) {\r\n            code += \"\\n\\n// user action\" + (mutations.length === 0 ? '(this action caused no changes)' : '') + \"\\n\";\r\n        }\r\n        // generate code to simulate user action\r\n        code += this.generateCodeForSimulatingUserAction(interaction);\r\n        if (this.addComments && mutations.length > 0) {\r\n            code += \"\\n\\n// check elements after '\" + interaction.eventName + \"' on '[data-hook=\\\"\" + interaction.dataHook + \"\\\"] element'\\n\";\r\n        }\r\n        // generate code to check values after interaction(user action)\r\n        code += this.generateCodeForCheckingValuesAfterInteraction(mutations, initMarkups);\r\n        return code;\r\n    };\r\n    PuppeteerTestGenerator.prototype.generateCodeForAsyncActionChunk = function (chunk, index, actionChunks, initMarkups) {\r\n        var _this = this;\r\n        var code = '';\r\n        var mutations = chunk.filter(helper_1.isDomMutationAction);\r\n        // generate code to check values before interaction(user action)\r\n        code += this.generateCodeToCheckMutationsBeforeInteraction(mutations, actionChunks, index);\r\n        var requestActions = chunk.filter(helper_1.isRequestAction);\r\n        var mutationsRaisedByUserInteraction = mutations.filter(function (mutation) { return !mutation.raisedByRequest; });\r\n        Console_1.default.log('mutationsRaisedByUserInteraction: ', mutationsRaisedByUserInteraction);\r\n        var callbackName = \"interceptRequestCallback\" + requestActions[0].id;\r\n        if (mutationsRaisedByUserInteraction.length > 0) {\r\n            code += \"\\n      \" + (this.addComments ? '// check DOM while requests are processing' : '') + \"\\n      await page.setRequestInterception(true);\\n      const \" + callbackName + \" = async interceptedRequest => {\\n        \" + requestActions\r\n                .map(function (requestAction) { return \"\\n            if (\\n              interceptedRequest.url() === '\" + requestAction.url + \"' &&\\n              interceptedRequest.method() === '\" + requestAction.method + \"'\\n            ) {\\n              \" + _this.generateCodeForCheckingValuesAfterInteraction(mutationsRaisedByUserInteraction, initMarkups) + \"\\n          };\\n          \"; })\r\n                .join('\\n') + \"\\n      interceptedRequest.continue();\\n      };\\n      page.on('request', \" + callbackName + \");\\n      \";\r\n        }\r\n        var userInteraction = chunk.find(helper_1.isUserInteractionAction);\r\n        if (index === 0 && typeof userInteraction === 'undefined') {\r\n            // if it is first chunk with async requests raised without user interaction\r\n        }\r\n        else {\r\n            code += this.generateCodeToWaitRequests(requestActions, this.generateCodeForSimulatingUserAction(userInteraction, false, true));\r\n        }\r\n        if (mutationsRaisedByUserInteraction.length > 0) {\r\n            code += \"\\n        page.removeListener('request', \" + callbackName + \");\\n        await page.setRequestInterception(false);\\n\\n\\n      \";\r\n        }\r\n        var mutationsRaisedByRequest = chunk.filter(function (mutation) { return helper_1.isDomMutationAction(mutation) && mutation.raisedByRequest; });\r\n        code += this.generateCodeForCheckingValuesAfterInteraction(mutationsRaisedByRequest, initMarkups);\r\n        return code;\r\n    };\r\n    return PuppeteerTestGenerator;\r\n}());\r\nexports.default = PuppeteerTestGenerator;\r\n\n\n//# sourceURL=webpack:///./src/client/PuppeteerTestGenerator.ts?");

/***/ }),

/***/ "./src/client/helper.ts":
/*!******************************!*\
  !*** ./src/client/helper.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isUserInteractionAction(action) {\r\n    return typeof action.eventName !== 'undefined';\r\n}\r\nexports.isUserInteractionAction = isUserInteractionAction;\r\nfunction isDomMutationAction(action) {\r\n    return typeof action.type !== 'undefined';\r\n}\r\nexports.isDomMutationAction = isDomMutationAction;\r\nfunction isRequestAction(action) {\r\n    return typeof action.url !== 'undefined';\r\n}\r\nexports.isRequestAction = isRequestAction;\r\n/**\r\n * Converts array of action chunks:\r\n * [\r\n *  [\r\n *    action1,\r\n *    mutation1\r\n *    ..\r\n *  ],\r\n *  [\r\n *    action2,\r\n *    mutation2,\r\n *  ]\r\n * ]\r\n * To Array of actions:\r\n *\r\n * [\r\n *  action1,\r\n *  mutation1\r\n *  ..\r\n *  action2,\r\n *  mutation2,\r\n * ]\r\n */\r\nfunction flatActionChunks(actionChunks) {\r\n    return actionChunks.reduce(function (acc, currVal) {\r\n        return acc.concat(currVal);\r\n    }, []);\r\n}\r\n/* Methods to get particular actions from Actions array*/\r\nfunction getMutationsFromActions(actions) {\r\n    return actions.filter(function (action) { return isDomMutationAction(action); });\r\n}\r\nfunction getRequestsFromActions(actions) {\r\n    return actions.filter(function (action) { return isRequestAction(action); });\r\n}\r\nfunction getMutationsFromActionChunks(actionChunks) {\r\n    return getMutationsFromActions(flatActionChunks(actionChunks));\r\n}\r\nexports.getMutationsFromActionChunks = getMutationsFromActionChunks;\r\nfunction getRequestsFromActionChunks(actionChunks) {\r\n    return getRequestsFromActions(flatActionChunks(actionChunks));\r\n}\r\nexports.getRequestsFromActionChunks = getRequestsFromActionChunks;\r\nfunction bothTypesAreAttributeOrNot(type1, type2) {\r\n    return ((type1 === type2 && type2 === 'attributes') ||\r\n        (type1 !== 'attributes' && type2 !== 'attributes'));\r\n}\r\nexports.bothTypesAreAttributeOrNot = bothTypesAreAttributeOrNot;\r\n\n\n//# sourceURL=webpack:///./src/client/helper.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PuppeteerTestGenerator_1 = __webpack_require__(/*! ./client/PuppeteerTestGenerator */ \"./src/client/PuppeteerTestGenerator.ts\");\r\nexports.PuppeteerTestGenerator = PuppeteerTestGenerator_1.default;\r\nvar CollectorComponent_1 = __webpack_require__(/*! ./CollectorComponent/CollectorComponent */ \"./src/CollectorComponent/CollectorComponent.jsx\");\r\nexports.CollectorComponent = CollectorComponent_1.default;\r\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ });